<!doctype html>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Level Editor — Edge Exits + TOML</title>
<style>
  :root { --grid:#cfd8dc; --wall:#000; --floor:#fff; --spawn:#1976d2; }
  body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#f6f7fb;color:#223}
  header{position:sticky;top:0;background:#fff;box-shadow:0 1px 0 rgba(0,0,0,.06);z-index:2;padding:8px 12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{display:flex;gap:6px;align-items:center}
  button{padding:6px 10px;border-radius:8px;border:1px solid #c7d0d9;background:#fff;cursor:pointer}
  button.primary{background:#0ea5e9;border-color:#0ea5e9;color:#fff}
  select,input[type=text],input[type=number]{padding:6px;border-radius:8px;border:1px solid #c7d0d9;background:#fff}
  .tool{padding:4px 8px;border:1px solid #c7d0d9;border-radius:6px;user-select:none}
  .tool.active{background:#e0f2fe;border-color:#0ea5e9}
  #cv{background:var(--floor);image-rendering:pixelated;box-shadow:0 6px 24px rgba(0,0,0,.1);touch-action:none}
  .banner{padding:8px 12px;background:#fee2e2;color:#7f1d1d;border:1px solid #fecaca;border-radius:8px;margin:8px 0;display:none;white-space:pre-line}
  .ok{background:#dcfce7;color:#14532d;border-color:#bbf7d0}
  textarea{width:100%;min-height:120px}
  #world{width:100%;height:44vh;background:#0e1118;box-shadow:0 6px 24px rgba(0,0,0,.15);cursor:grab}
  #world:active{cursor:grabbing}
  .edge{display:flex;gap:6px;align-items:center}
  select.bad{border-color:#ef4444; background:#fee2e2;}
  .muted{color:#6b7280}
</style>

<header>
  <div class="row">
    <button id="newMap">New Map</button>
    <input id="mapName" type="text" placeholder="Map name"/>
    <label>W<input id="w" type="number" min="4" max="300" value="99"></label>
    <label>H<input id="h" type="number" min="4" max="300" value="70"></label>
    <label>Spawn W<input id="sw" type="number" min="1" max="8" value="2"></label>
    <label>Spawn H<input id="sh" type="number" min="1" max="8" value="2"></label>
    <button id="resize" class="primary">Resize</button>

    <span class="tool" id="paintWall" title="1">Wall (#)</span>
    <span class="tool" id="paintErase" title="2">Erase ( )</span>
    <span class="tool" id="paintSpawn" title="3 or P">Spawn (P)</span>

    <select id="maps"></select>
    <button id="exportBtn">Export TOML</button>
    <label><input id="importFiles" type="file" multiple accept=".toml"/> Load TOML(s)</label>
    <button id="openFolder" style="display:none">Open Folder…</button><span id="fsHint" class="muted"></span>
  </div>

  <div class="row" style="margin-top:6px">
    <div class="edge">Left→   <select id="edge_left"></select></div>
    <div class="edge">Right→  <select id="edge_right"></select></div>
    <div class="edge">Top→    <select id="edge_top"></select></div>
    <div class="edge">Bottom→ <select id="edge_bottom"></select></div>
  </div>

  <div id="warn" class="banner"></div>
</header>

<main style="padding:12px;display:grid;gap:12px">
  <canvas id="cv" width="960" height="540"></canvas>

  <section>
    <strong>Current map TOML</strong>
    <textarea id="toml"></textarea>
  </section>

  <section>
    <div class="row"><button id="renderWorld">World Overview</button>
      <label>Zoom <input id="z" type="range" min="0.2" max="4" step="0.05" value="1"></label>
    </div>
    <canvas id="world"></canvas>
  </section>
</main>

<script>
const cv = document.getElementById('cv'), ctx = cv.getContext('2d');
const mapsSel = document.getElementById('maps');
const nameIn = document.getElementById('mapName');
const wIn = document.getElementById('w'), hIn = document.getElementById('h');
const swIn = document.getElementById('sw'), shIn = document.getElementById('sh');
const warn = document.getElementById('warn');
const tomlArea = document.getElementById('toml');

const edgeSel = {
  left: document.getElementById('edge_left'),
  right: document.getElementById('edge_right'),
  top: document.getElementById('edge_top'),
  bottom: document.getElementById('edge_bottom'),
};

const tools = { wall:'paintWall', erase:'paintErase', spawn:'paintSpawn' };
let tool = 'wall';

const model = {
  maps: new Map(), // id -> {id,name,W,H,grid,spawn:{x,y,w,h}, exits:{left?,right?,top?,bottom?}, chars:{wall,floor}}
  current: null
};
const CH = { wall:'#', floor:' ' };

function uuid(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
    const r = Math.random()*16|0, v = c=='x' ? r : (r&0x3|0x8); return v.toString(16);
  });
}

function makeNewMap(){
  const id = uuid();
  const data = {
    id, name: `Map ${model.maps.size+1}`,
    W: +wIn.value || 99, H: +hIn.value || 70,
    grid: Array.from({length:+hIn.value||70}, ()=>Array.from({length:+wIn.value||99}, ()=> CH.floor)),
    spawn: {x:1,y:1,w:+swIn.value||2,h:+shIn.value||2},
    exits: {left:null,right:null,top:null,bottom:null},
    chars: {...CH}
  };
  model.maps.set(id, data);
  setCurrent(id);
}
function setCurrent(id){
  model.current = id;
  syncHeader();
  fit(); draw(); syncToml(); runLint();
}
function cur(){ return model.maps.get(model.current); }

// ————— Edge helpers —————
const OPP = { left:"right", right:"left", top:"bottom", bottom:"top" };

// When a select changes, set A.side = B, and auto-recursively set B.OPP = A if empty or already pointing to A.
function onEdgeChange(side, toId){
  const A = cur(); // current map
  A.exits[side] = (toId === "none") ? null : toId || null;

  // auto-reciprocal if target exists
  if (A.exits[side] && model.maps.has(A.exits[side])){
    const B = model.maps.get(A.exits[side]);
    const opp = OPP[side];
    if (!B.exits[opp] || B.exits[opp] === A.id){
      B.exits[opp] = A.id;
    }
  }
  syncHeader();
  syncToml();
  runLint();
}

// UI wiring
document.getElementById('newMap').onclick = makeNewMap;
document.getElementById('resize').onclick = ()=>{
  const m=cur(); m.W=+wIn.value; m.H=+hIn.value;
  m.grid = Array.from({length:m.H}, (_,y)=>Array.from({length:m.W},(_,x)=> (m.grid[y]?.[x] ?? CH.floor)));
  m.spawn.w = +swIn.value; m.spawn.h = +shIn.value;
  fit(); draw(); syncToml(); validateSpawn(); runLint();
};
mapsSel.onchange = e => setCurrent(e.target.value);
nameIn.onchange = e => { cur().name = e.target.value || cur().name; syncHeader(); syncToml(); runLint(); };

for (const side of ["left","right","top","bottom"]){
  edgeSel[side].onchange = e => onEdgeChange(side, e.target.value);
}

// Keyboard shortcuts: 1=wall, 2=erase, 3 or P=spawn
addEventListener('keydown', e=>{
  if (e.key === '1') setTool('wall');
  if (e.key === '2') setTool('erase');
  if (e.key === '3' || e.key.toLowerCase() === 'p') setTool('spawn');
});

document.getElementById('exportBtn').onclick = ()=>{
  const blob = new Blob([toToml(cur())], {type:'text/plain'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = (cur().name.replace(/\s+/g,'_').toLowerCase() + ".toml"); a.click();
};

document.getElementById('importFiles').addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files);
  for (const f of files){
    const txt = await f.text();
    const obj = fromToml(txt);
    model.maps.set(obj.id, obj);
  }
  setCurrent(model.current ?? model.maps.keys().next().value);
});

// Optional: folder import (Chromium)
const openFolderBtn = document.getElementById('openFolder');
const fsHint = document.getElementById('fsHint');
if ('showDirectoryPicker' in window){
  openFolderBtn.style.display = 'inline-block';
  fsHint.textContent = ' (Folder import available)';
  openFolderBtn.onclick = async ()=>{
    const dir = await window.showDirectoryPicker();
    for await (const [name, handle] of dir.entries()){
      if (name.toLowerCase().endsWith('.toml')){
        const file = await handle.getFile();
        const txt = await file.text();
        const obj = fromToml(txt);
        model.maps.set(obj.id, obj);
      }
    }
    setCurrent(model.current ?? model.maps.keys().next().value);
  };
}

// Auto-discover ./maps/ on page load:
// 1) try maps/manifest.json (["maps/plains.toml", ...])
// 2) else parse the HTML listing at maps/ (works with `npx serve`)
window.addEventListener('DOMContentLoaded', async ()=>{
  let found = 0;
  const urls = new Set();

  // (1) manifest
  try {
    const r = await fetch('maps/manifest.json');
    if (r.ok){
      const list = await r.json();
      for (const u of list) urls.add(u);
    }
  } catch {}

  // Load
  for (const url of urls){
    try{
      const txt = await (await fetch(url)).text();
      const obj = fromToml(txt);
      model.maps.set(obj.id, obj);
      found++;
    }catch{}
  }
  if (found > 0) setCurrent(model.maps.keys().next().value);
  else makeNewMap(); // fallback blank
});


// Painting
let down=false;
cv.addEventListener('pointerdown', e=>{ down=true; paint(e); });
cv.addEventListener('pointermove', e=>{ if (down) paint(e); });
addEventListener('pointerup', ()=> down=false);

function setTool(t){
  tool = t;
  for (const [k,id] of Object.entries(tools)){
    document.getElementById(id).classList.toggle('active', k===t);
  }
}
for (const [k,id] of Object.entries(tools)){ document.getElementById(id).onclick = ()=> setTool(k); }
setTool('wall');

function toCell(e){
  const rect = cv.getBoundingClientRect();
  const px = e.clientX - rect.left, py = e.clientY - rect.top;
  const tw = cv.width / cur().W, th = cv.height / cur().H;
  return { x: Math.floor(px / tw), y: Math.floor(py / th) };
}
function inBounds(x,y){ const m=cur(); return x>=0 && y>=0 && x<m.W && y<m.H; }

function paint(e){
  const m = cur(); const {x,y} = toCell(e); if (!inBounds(x,y)) return;
  if (tool==='wall'){ m.grid[y][x] = m.chars.wall; }
  else if (tool==='erase'){ m.grid[y][x] = m.chars.floor; }
  else if (tool==='spawn'){ m.spawn.x = x; m.spawn.y = y; }
  draw(); syncToml(); validateSpawn(); runLint();
}

// Spawn validation
function validateSpawn(){
  const m = cur();
  const ok = rectIsClear(m, m.spawn.x, m.spawn.y, m.spawn.w, m.spawn.h);
  warn.style.display = ok ? 'none' : 'block';
  warn.textContent = ok ? '' : 'Spawn overlaps walls: ensure a clear area of size Spawn W×H.';
}

// Header / selects
function syncHeader(){
  const m = cur();
  nameIn.value = m.name;
  wIn.value = m.W; hIn.value = m.H; swIn.value = m.spawn.w; shIn.value = m.spawn.h;

  mapsSel.innerHTML = '';
  for (const [id, map] of model.maps.entries()){
    const o = document.createElement('option'); o.value=id; o.textContent=`${map.name} (${id.slice(0,8)})`;
    if (id===model.current) o.selected = true; mapsSel.appendChild(o);
  }
  const opts = [['none','— None —'], ...Array.from(model.maps.entries()).map(([id,m])=>[id, m.name])];
  for (const side of ["left","right","top","bottom"]){
    const sel = edgeSel[side];
    const prev = sel.value;
    sel.innerHTML = '';
    for (const [val,label] of opts){ const o=document.createElement('option'); o.value=val; o.textContent=label; sel.appendChild(o); }
    sel.value = cur().exits[side] ?? 'none';
  }
  validateSpawn();
}

// Keep TOML textarea current
function syncToml(){ tomlArea.value = toToml(cur()); }

// Render map
function fit(){
  const maxW = Math.min(innerWidth - 24, 1200);
  const aspect = cur().W / cur().H;
  let cw = maxW, ch = Math.round(cw / aspect);
  const maxH = innerHeight * 0.55;
  if (ch > maxH){ ch = Math.round(maxH); cw = Math.round(ch * aspect); }
  cv.width = cw; cv.height = ch;
}
addEventListener('resize', ()=>{ fit(); draw(); });

function draw(){
  const m = cur();
  const tw = cv.width / m.W, th = cv.height / m.H;

  ctx.fillStyle = getCSS('--floor','#fff'); ctx.fillRect(0,0,cv.width,cv.height);

  // grid
  ctx.strokeStyle = getCSS('--grid','#cfd8dc'); ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x=0;x<=m.W;x++){ const px = Math.round(x*tw)+.5; ctx.moveTo(px,0); ctx.lineTo(px,cv.height); }
  for (let y=0;y<=m.H;y++){ const py = Math.round(y*th)+.5; ctx.moveTo(0,py); ctx.lineTo(cv.width,py); }
  ctx.stroke();

  // tiles (draw all cells; spaces show as floor)
  for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
    if (m.grid[y][x]===m.chars.wall){
      ctx.fillStyle = getCSS('--wall','#000');
      ctx.fillRect(Math.round(x*tw), Math.round(y*th), Math.ceil(tw), Math.ceil(th));
    }
  }
  // spawn rectangle
  ctx.fillStyle = getCSS('--spawn','#1976d2');
  ctx.fillRect(Math.round(m.spawn.x*tw), Math.round(m.spawn.y*th), Math.ceil(m.spawn.w*tw), Math.ceil(m.spawn.h*th));
}

// TOML IO — preserve whitespace and blank rows
function toToml(m){
  const lines = m.grid.map(r => r.join("")); // keep trailing spaces by not trimming
  return [
    `id = "${m.id}"`,
    `name = "${m.name.replace(/"/g,'\\"')}"`,
    ``,
    `[tiles]`,
    `wall = "${m.chars.wall}"`,
    `floor = "${m.chars.floor}"`,
    ``,
    `[spawn]`,
    `x = ${m.spawn.x}`, `y = ${m.spawn.y}`, `w = ${m.spawn.w}`, `h = ${m.spawn.h}`,
    ``,
    `grid = """`,
    ...lines,
    `"""`,
    ``,
    `[exits]`,
    ...(m.exits.left   ? [`left = "${m.exits.left}"`]   : []),
    ...(m.exits.right  ? [`right = "${m.exits.right}"`] : []),
    ...(m.exits.top    ? [`top = "${m.exits.top}"`]     : []),
    ...(m.exits.bottom ? [`bottom = "${m.exits.bottom}"`] : []),
    ``
  ].join("\n");
}
function fromToml(txt){
  const t = parseTOML(txt);
  const rows = String(t.grid).replace(/\r\n?/g,"\n").split("\n"); // no trimming
  const H = rows.length, W = Math.max(...rows.map(r=>r.length));
  const grid = Array.from({length:H}, (_,y)=>{
    const line = rows[y] ?? "";
    const padded = line.padEnd(W, (t.tiles?.floor ?? ' '));
    return Array.from({length:W}, (_,x)=> padded[x] ?? (t.tiles?.floor ?? ' '));
  });
  return {
    id: t.id, name: t.name || t.id.slice(0,8),
    W, H, grid,
    spawn: { x: t.spawn.x, y: t.spawn.y, w: t.spawn.w, h: t.spawn.h },
    exits: { left: t.exits?.left ?? null, right: t.exits?.right ?? null, top: t.exits?.top ?? null, bottom: t.exits?.bottom ?? null },
    chars: { wall: t.tiles?.wall ?? '#', floor: t.tiles?.floor ?? ' ' }
  };
}

function parseTOML(src){
  const out = {}; let ctx = out, inML=false, mlKey="", mlBuf=[], mlTarget=out;
  const isRootKey = k => (k === "id" || k === "name" || k === "grid");
  const set=(obj,k,v)=>obj[k]=v;
  const lines = src.replace(/\r\n?/g,"\n").split("\n");

  for (let raw of lines){
    const line = raw.trim();
    if (!inML){
      if (!line || line.startsWith("#")) continue;
      let m;
      if ((m=line.match(/^\[([A-Za-z0-9_]+)\]$/))){ const k=m[1]; out[k]??={}; ctx=out[k]; continue; }
      if ((m=line.match(/^([A-Za-z0-9_]+)\s*=\s*"""$/))){ 
        const key=m[1]; inML=true; mlKey=key; mlBuf=[]; mlTarget=isRootKey(key)?out:ctx; continue; 
      }
      if ((m=line.match(/^([A-Za-z0-9_]+)\s*=\s*(.+)$/))){
        const key=m[1]; let rhs=m[2].trim(); let val;
        if ((/^".*"$/.test(rhs)) || (/^'.*'$/.test(rhs))) val=rhs.slice(1,-1);
        else if (/^(true|false)$/i.test(rhs)) val=/^true$/i.test(rhs);
        else if (/^-?\d+$/.test(rhs)) val=parseInt(rhs,10);
        else /* unknown -> ignore */ val = undefined;
        if (val !== undefined) set(isRootKey(key)?out:ctx, key, val);
        continue;
      }
    } else {
      if (line === `"""`){ set(mlTarget, mlKey, mlBuf.join("\n")); inML=false; mlKey=""; mlBuf=[]; mlTarget=out; }
      else mlBuf.push(raw);
    }
  }
  if (inML) throw new Error("Unterminated multiline string");
  return out;
}



// Lint: dangling and conflicts
function runLint(){
  const problems = [];
  // clear styles
  for (const s of Object.values(edgeSel)) s.classList.remove('bad');

  for (const [id,m] of model.maps.entries()){
    for (const [side,to] of Object.entries(m.exits)){
      if (!to) continue;
      if (!model.maps.has(to)){
        if (id === model.current) edgeSel[side].classList.add('bad');
        problems.push(`Dangling: ${m.name} ${side} → ${to} (missing map)`);
        continue;
      }
      const opp = OPP[side];
      const n = model.maps.get(to);
      if (!n.exits[opp]){
        // auto-reciprocal if empty
        n.exits[opp] = id;
      } else if (n.exits[opp] !== id){
        if (id === model.current) edgeSel[side].classList.add('bad');
        problems.push(`Conflict: ${m.name} ${side} → ${n.name}, but ${n.name} ${opp} → ${short(n.exits[opp])}`);
      }
    }
  }

  if (problems.length){
    warn.classList.remove('ok');
    warn.style.display = 'block';
    warn.textContent = problems.join("\n");
  } else {
    warn.classList.add('ok');
    warn.style.display = 'block';
    warn.textContent = '✓ No link issues';
  }
}

function short(id){
  const m = model.maps.get(id);
  return m ? `${m.name}` : id.slice(0,8);
}

// World overview
// World overview — clickable atlas
const worldCv = document.getElementById('world'), wctx = worldCv.getContext('2d');
let Z=1, pan={x:20,y:20}, dragging=false, last={x:0,y:0};
let worldRects = []; // [{id,x,y,w,h}] in world coords (pre-translate/scale)
let hoverId = null;

document.getElementById('renderWorld').onclick = drawWorld;
document.getElementById('z').oninput = e => { Z=+e.target.value; drawWorld(); };

worldCv.addEventListener('pointerdown', e=>{
  const pt = worldPoint(e);
  // If we clicked a map rect: select it; else begin pan
  const hit = hitTest(pt.x, pt.y);
  if (hit){ setCurrent(hit.id); drawWorld(); return; }
  dragging=true; last={x:e.clientX,y:e.clientY};
});
addEventListener('pointerup', ()=> dragging=false);
addEventListener('pointermove', e=>{
  if (dragging){
    pan.x+=e.clientX-last.x; pan.y+=e.clientY-last.y; last={x:e.clientX,y:e.clientY};
    drawWorld(); return;
  }
  // hover
  const pt = worldPoint(e);
  const hit = hitTest(pt.x, pt.y);
  const nextHover = hit ? hit.id : null;
  if (nextHover !== hoverId){
    hoverId = nextHover;
    worldCv.style.cursor = hoverId ? 'pointer' : 'grab';
    drawWorld();
  }
});

function layout(){
  const pos = new Map(), q = [];
  const DIR = { left:{x:-1,y:0}, right:{x:1,y:0}, top:{x:0,y:-1}, bottom:{x:0,y:1} };
  const start = model.current ?? Array.from(model.maps.keys())[0];
  if (!start) return pos;
  pos.set(start, {x:0,y:0}); q.push(start);
  while(q.length){
    const id = q.shift(), p = pos.get(id), m = model.maps.get(id);
    for (const [side,to] of Object.entries(m.exits)){
      if (!to || !model.maps.has(to)) continue;
      if (!pos.has(to)){
        const d = DIR[side];
        pos.set(to, { x: p.x + d.x, y: p.y + d.y });
        q.push(to);
      }
    }
  }
  return pos;
}

function drawWorld(){
  resizeWorld();
  wctx.clearRect(0,0,worldCv.width,worldCv.height);
  const pos = layout(); wctx.save(); wctx.translate(pan.x, pan.y); wctx.scale(Z,Z);
  const tile = 6;

  worldRects = [];

  // links first
  wctx.strokeStyle="#4b5563"; wctx.lineWidth = 1/Z;
  for (const [id,p] of pos){
    const m = model.maps.get(id); if (!m) continue;
    const A = {x: p.x*(m.W+4)*tile, y: p.y*(m.H+4)*tile, w: m.W*tile, h: m.H*tile};
    for (const [side,to] of Object.entries(m.exits)){
      if (!to || !pos.has(to)) continue;
      const n = model.maps.get(to), q = pos.get(to);
      const B = {x: q.x*(n.W+4)*tile, y: q.y*(n.H+4)*tile, w: n.W*tile, h: n.H*tile};
      wctx.beginPath(); wctx.moveTo(A.x+A.w/2, A.y+A.h/2); wctx.lineTo(B.x+B.w/2, B.y+B.h/2); wctx.stroke();
    }
  }

  // maps
  for (const [id,p] of pos){
    const m = model.maps.get(id); if (!m) continue;
    const ox = p.x*(m.W+4)*tile, oy = p.y*(m.H+4)*tile;
    const rect = { id, x: ox, y: oy, w: m.W*tile, h: m.H*tile };
    worldRects.push(rect);

    // card bg + title
    wctx.fillStyle="#111827"; wctx.fillRect(ox-4, oy-24, m.W*tile+8, m.H*tile+28);
    wctx.fillStyle="#e5e7eb"; wctx.fillText(`${m.name}`, ox, oy-8);

    // map cells
    for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
      wctx.fillStyle = (m.grid[y][x]===m.chars.wall) ? "#000" : "#fff";
      wctx.fillRect(ox+x*tile, oy+y*tile, tile, tile);
    }

    // spawn
    wctx.fillStyle="#1976d2";
    wctx.fillRect(ox+m.spawn.x*tile, oy+m.spawn.y*tile, m.spawn.w*tile, m.spawn.h*tile);

    // highlight hover/current
    if (id === hoverId || id === model.current){
      wctx.lineWidth = 2/Z;
      wctx.strokeStyle = (id === model.current) ? "#22c55e" : "#eab308";
      wctx.strokeRect(rect.x-2, rect.y-2, rect.w+4, rect.h+4);
    }
  }

  wctx.restore();
}

function resizeWorld(){ worldCv.width = innerWidth - 24; worldCv.height = Math.round(innerHeight * 0.44); }

function worldPoint(e){
  const r = worldCv.getBoundingClientRect();
  const x = (e.clientX - r.left - pan.x) / Z;
  const y = (e.clientY - r.top  - pan.y) / Z;
  return { x, y };
}
function hitTest(x,y){
  for (let i=worldRects.length-1;i>=0;i--){
    const r = worldRects[i];
    if (x>=r.x && y>=r.y && x<=r.x+r.w && y<=r.y+r.h) return r;
  }
  return null;
}




function rectIsClear(m, x, y, w, h){
  for (let ty=y; ty<y+h; ty++) for (let tx=x; tx<x+w; tx++){
    if (m.grid[ty]?.[tx] === m.chars.wall) return false;
  }
  return true;
}
function getCSS(name, fallback){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback; }
</script>
