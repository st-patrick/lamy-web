<!doctype html>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Level Editor — Edge Exits + TOML</title>
<style>
  :root { --grid:#cfd8dc; --wall:#000; --floor:#fff; --spawn:#1976d2; }
  body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#f6f7fb;color:#223}
  header{position:sticky;top:0;background:#fff;box-shadow:0 1px 0 rgba(0,0,0,.06);z-index:2;padding:8px 12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{display:flex;gap:6px;align-items:center}
  button{padding:6px 10px;border-radius:8px;border:1px solid #c7d0d9;background:#fff;cursor:pointer}
  button.primary{background:#0ea5e9;border-color:#0ea5e9;color:#fff}
  select,input[type=text],input[type=number]{padding:6px;border-radius:8px;border:1px solid #c7d0d9;background:#fff}
  .tool{padding:4px 8px;border:1px solid #c7d0d9;border-radius:6px;user-select:none}
  .tool.active{background:#e0f2fe;border-color:#0ea5e9}
  #cv{background:var(--floor);image-rendering:pixelated;box-shadow:0 6px 24px rgba(0,0,0,.1);touch-action:none}
  .banner{padding:8px 12px;background:#fee2e2;color:#7f1d1d;border:1px solid #fecaca;border-radius:8px;margin:8px 0;display:none;white-space:pre-line}
  .ok{background:#dcfce7;color:#14532d;border-color:#bbf7d0}
  #world{width:100%;height:44vh;background:#0e1118;box-shadow:0 6px 24px rgba(0,0,0,.15);cursor:grab}
  #world:active{cursor:grabbing}
  .edge{display:flex;gap:6px;align-items:center}
  select.bad{border-color:#ef4444; background:#fee2e2;}
  .muted{color:#6b7280}
</style>

<header>
  <div class="row">
    <button id="newMap">New Map</button>
    <input id="mapName" type="text" placeholder="Map name"/>
    <label>W<input id="w" type="number" min="4" max="300" value="99"></label>
    <label>H<input id="h" type="number" min="4" max="300" value="70"></label>
    <label>Spawn W<input id="sw" type="number" min="1" max="8" value="2"></label>
    <label>Spawn H<input id="sh" type="number" min="1" max="8" value="2"></label>
    <button id="resize" class="primary">Resize</button>

    <span class="tool" id="paintWall" title="1">Wall (#)</span>
    <span class="tool" id="paintErase" title="2">Erase ( )</span>
    <span class="tool" id="paintSpawn" title="3 or P">Spawn (P)</span>

    <select id="maps"></select>
    <button id="saveMaps">Save Maps…</button>
    <button id="reloadMaps">Reload Maps</button>
  </div>

  <div class="row" style="margin-top:6px">
    <div class="edge">Left→   <select id="edge_left"></select></div>
    <div class="edge">Right→  <select id="edge_right"></select></div>
    <div class="edge">Top→    <select id="edge_top"></select></div>
    <div class="edge">Bottom→ <select id="edge_bottom"></select></div>
  </div>

  <div id="warn" class="banner"></div>
</header>

<main style="padding:12px;display:grid;gap:12px">
  <canvas id="cv" width="960" height="540"></canvas>

  <section>
    <div class="row"><button id="renderWorld">World Overview</button>
      <label>Zoom <input id="z" type="range" min="0.2" max="4" step="0.05" value="1"></label>
    </div>
    <canvas id="world"></canvas>
  </section>
</main>

<script>
const cv = document.getElementById('cv'), ctx = cv.getContext('2d');
const mapsSel = document.getElementById('maps');
const nameIn = document.getElementById('mapName');
const wIn = document.getElementById('w'), hIn = document.getElementById('h');
const swIn = document.getElementById('sw'), shIn = document.getElementById('sh');
const warn = document.getElementById('warn');
const saveMapsBtn = document.getElementById('saveMaps');
const reloadMapsBtn = document.getElementById('reloadMaps');
let currentToml = '';

const edgeSel = {
  left: document.getElementById('edge_left'),
  right: document.getElementById('edge_right'),
  top: document.getElementById('edge_top'),
  bottom: document.getElementById('edge_bottom'),
};

const tools = { wall:'paintWall', erase:'paintErase', spawn:'paintSpawn' };
let tool = 'wall';

const model = {
  maps: new Map(), // id -> {id,name,W,H,grid,spawn:{x,y,w,h}, exits:{left?,right?,top?,bottom?}, chars:{wall,floor}}
  current: null
};
const CH = { wall:'#', floor:' ' };
const staleFolderEntries = new Set();

function slugifyName(name){
  return String(name ?? '')
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g,'_')
    .replace(/^_+|_+$/g,'')
    || 'map';
}

function ensureFilename(map, usedNames){
  if (map.filename){
    if (usedNames) usedNames.add(map.filename);
    return map.filename;
  }
  const base = slugifyName(map.name);
  let candidate = `${base}.toml`;
  let suffix = 2;
  while (usedNames && usedNames.has(candidate)){
    candidate = `${base}_${suffix++}.toml`;
  }
  map.filename = candidate;
  if (usedNames) usedNames.add(candidate);
  return candidate;
}

function makeEmptyExtras(){
  return { meta:null, legend:null, palette:null, layers:null, triggers:[], poi:[] };
}

function cloneExtrasFromToml(t){
  const extras = makeEmptyExtras();
  if (t.meta && typeof t.meta === 'object') extras.meta = { ...t.meta };
  if (t.legend && typeof t.legend === 'object') extras.legend = { ...t.legend };
  if (t.palette && typeof t.palette === 'object') extras.palette = { ...t.palette };
  if (t.layers && typeof t.layers === 'object'){
    extras.layers = {};
    for (const [layerName, layerData] of Object.entries(t.layers)){
      if (!layerData || typeof layerData !== 'object') continue;
      extras.layers[layerName] = {};
      for (const [k, v] of Object.entries(layerData)){
        extras.layers[layerName][k] = (typeof v === 'object' && v !== null)
          ? JSON.parse(JSON.stringify(v))
          : v;
      }
    }
  }
  if (Array.isArray(t.triggers)) extras.triggers = t.triggers.map(entry => ({ ...entry }));
  if (Array.isArray(t.poi)) extras.poi = t.poi.map(entry => ({ ...entry }));
  return extras;
}

function backgroundGrid(map){
  const raw = map?.extras?.layers?.background?.grid;
  if (typeof raw !== 'string') return null;
  const key = `${map.W}x${map.H}:${raw.length}`;
  if (!map._bgCache || map._bgCache.key !== key || map._bgCache.raw !== raw){
    const lines = raw.replace(/\r\n?/g,"\n").split("\n");
    const grid = Array.from({length:map.H}, (_,y)=>{
      const line = lines[y] ?? "";
      const padded = line.padEnd(map.W, ' ');
      return Array.from({length:map.W}, (_,x)=> padded[x] ?? ' ');
    });
    map._bgCache = { key, raw, grid };
  }
  return map._bgCache.grid;
}

function backgroundPalette(map){
  const palette = map?.extras?.palette;
  if (!palette || typeof palette !== 'object') return null;
  if (!map._paletteCache || map._paletteCache.source !== palette){
    map._paletteCache = { source: palette, entries: { ...palette } };
  }
  return map._paletteCache.entries;
}

function clearModel(){
  model.maps.clear();
  model.current = null;
  mapsSel.innerHTML = '';
  warn.textContent = '';
  warn.style.display = 'none';
  warn.classList.remove('ok');
  ctx.clearRect(0, 0, cv.width, cv.height);
  console.log('[Editor] Model cleared');
}

function uuid(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
    const r = Math.random()*16|0, v = c=='x' ? r : (r&0x3|0x8); return v.toString(16);
  });
}

function makeNewMap(){
  const id = uuid();
  const data = {
    id, name: `Map ${model.maps.size+1}`,
    W: +wIn.value || 99, H: +hIn.value || 70,
    grid: Array.from({length:+hIn.value||70}, ()=>Array.from({length:+wIn.value||99}, ()=> CH.floor)),
    spawn: {x:1,y:1,w:+swIn.value||2,h:+shIn.value||2},
    exits: {left:null,right:null,top:null,bottom:null},
    chars: {...CH},
    extras: makeEmptyExtras(),
    filename: null,
    source: null
  };
  model.maps.set(id, data);
  setCurrent(id);
}
function setCurrent(id){
  model.current = id;
  syncHeader();
  fit(); draw(); syncToml(); runLint();
}
function cur(){ return model.maps.get(model.current); }

// ————— Edge helpers —————
const OPP = { left:"right", right:"left", top:"bottom", bottom:"top" };

// When a select changes, set A.side = B, and auto-recursively set B.OPP = A if empty or already pointing to A.
function onEdgeChange(side, toId){
  const A = cur(); // current map
  const oldExit = A.exits[side];
  A.exits[side] = (toId === "none") ? null : toId || null;

  // auto-reciprocal if target exists
  let autoLinked = false;
  if (A.exits[side] && model.maps.has(A.exits[side])){
    const B = model.maps.get(A.exits[side]);
    const opp = OPP[side];
    if (!B.exits[opp] || B.exits[opp] === A.id){
      if (!B.exits[opp]) {
        B.exits[opp] = A.id;
        autoLinked = true;
      }
    }
  }
  
  // Clean up old reciprocal link if we changed the exit
  if (oldExit && oldExit !== A.exits[side] && model.maps.has(oldExit)) {
    const oldB = model.maps.get(oldExit);
    const opp = OPP[side];
    if (oldB.exits[opp] === A.id) {
      oldB.exits[opp] = null;
    }
  }
  
  if (autoLinked) {
    const targetMap = model.maps.get(A.exits[side]);
    showNotification(`Auto-linked ${targetMap.name} ${OPP[side]} → ${A.name}`);
  }
  
  syncHeader();
  syncToml();
  runLint();
}

// UI wiring
document.getElementById('newMap').onclick = makeNewMap;
document.getElementById('resize').onclick = ()=>{
  const m=cur(); m.W=+wIn.value; m.H=+hIn.value;
  m.grid = Array.from({length:m.H}, (_,y)=>Array.from({length:m.W},(_,x)=> (m.grid[y]?.[x] ?? CH.floor)));
  m.spawn.w = +swIn.value; m.spawn.h = +shIn.value;
  fit(); draw(); syncToml(); validateSpawn(); runLint();
};
mapsSel.onchange = e => setCurrent(e.target.value);
nameIn.onchange = e => { cur().name = e.target.value || cur().name; syncHeader(); syncToml(); runLint(); };

for (const side of ["left","right","top","bottom"]){
  edgeSel[side].onchange = e => onEdgeChange(side, e.target.value);
}

// Keyboard shortcuts: 1=wall, 2=erase, 3 or P=spawn
addEventListener('keydown', e=>{
  if (e.key === '1') setTool('wall');
  if (e.key === '2') setTool('erase');
  if (e.key === '3' || e.key.toLowerCase() === 'p') setTool('spawn');
});

if (saveMapsBtn) saveMapsBtn.onclick = handleSaveMapsClick;
if (reloadMapsBtn) reloadMapsBtn.onclick = handleReloadMapsClick;

async function saveFileToDirectory(handle, filename, content) {
  if (!handle) throw new Error('No directory handle available');

  try {
    console.log(`Attempting to save ${filename}...`);

    try {
      await handle.removeEntry(filename);
      console.log(`Removed existing ${filename}`);
    } catch (removeErr) {
      if (removeErr.name !== 'NotFoundError') {
        console.log(`File ${filename} doesn't exist yet, will create new`);
      } else {
        console.log(`Could not remove ${filename}, will try to overwrite:`, removeErr);
      }
    }

    const fileHandle = await handle.getFileHandle(filename, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    console.log(`✅ Successfully saved ${filename}`);
  } catch (err) {
    console.error(`❌ Failed to save ${filename}:`, err);

    if (err.name === 'InvalidStateError') {
      throw new Error(`Directory handle expired for ${filename}. Please re-select the folder.`);
    }

    if (err.name === 'NotAllowedError') {
      throw new Error(`Permission denied for ${filename}. File may be open elsewhere or access was revoked.`);
    }

    throw err;
  }
}

function fallbackDownload(content, filename) {
  const blob = new Blob([content], {type:'text/plain'});
  const a = document.createElement('a'); 
  a.href = URL.createObjectURL(blob);
  a.download = filename; 
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 100);
}

function showNotification(message) {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 1000;
    background: #22c55e; color: white; padding: 12px 20px;
    border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-weight: 500; animation: fadeInOut 3s ease-in-out;
  `;
  notification.textContent = message;
  
  // Add CSS animation
  if (!document.getElementById('notification-styles')) {
    const style = document.createElement('style');
    style.id = 'notification-styles';
    style.textContent = `
      @keyframes fadeInOut {
        0% { opacity: 0; transform: translateX(100%); }
        15%, 85% { opacity: 1; transform: translateX(0); }
        100% { opacity: 0; transform: translateX(100%); }
      }
    `;
    document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 3000);
}

let directoryHandle = null;

function forgetDirectoryHandle(){ directoryHandle = null; }

async function ensureDirectoryHandle(){
  if (!('showDirectoryPicker' in window)) return null;
  if (directoryHandle) {
    try {
      const status = await directoryHandle.queryPermission?.({ mode: 'readwrite' });
      if (status === 'granted') return directoryHandle;
      if (status === undefined) return directoryHandle;
      if (status === 'denied') {
        forgetDirectoryHandle();
      } else if (status === 'prompt') {
        const granted = await directoryHandle.requestPermission?.({ mode: 'readwrite' });
        if (granted === 'granted') return directoryHandle;
        forgetDirectoryHandle();
      }
    } catch {
      forgetDirectoryHandle();
    }
  }
  try {
    const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
    directoryHandle = handle;
    return handle;
  } catch (err) {
    if (err?.name !== 'AbortError') {
      console.error('Directory selection failed:', err);
      showNotification('Unable to access folder; falling back to downloads.');
    }
    return null;
  }
}

async function handleSaveMapsClick(){
  if (!model.maps.size){
    showNotification('No maps in workspace.');
    return;
  }

  const handle = await ensureDirectoryHandle();
  const fallbackOnly = !handle;
  const usedNames = new Set();
  for (const m of model.maps.values()){
    if (m.filename) usedNames.add(m.filename);
  }
  let saved = 0;
  let failed = 0;
  let expired = false;

  if (handle && staleFolderEntries.size){
    for (const name of Array.from(staleFolderEntries)){
      try {
        await handle.removeEntry(name);
        staleFolderEntries.delete(name);
        console.log(`[Editor] Removed stale duplicate file ${name}`);
      } catch (err) {
        console.warn(`Failed to remove stale file ${name}:`, err);
      }
    }
  }

  for (const map of model.maps.values()){
    const filename = ensureFilename(map, usedNames);
    const content = toToml(map);

    if (!fallbackOnly && !expired){
      try {
  await saveFileToDirectory(handle, filename, content);
  map.filename = filename;
  map.source = `folder:${filename}`;
        saved++;
        continue;
      } catch (err) {
        console.error(`Failed to save ${filename}:`, err);
        failed++;
        if (err?.message?.includes('Directory handle expired') || err?.name === 'InvalidStateError'){
          forgetDirectoryHandle();
          expired = true;
          showNotification('Folder access expired — downloading remaining maps.');
        } else {
          showNotification(`Save issue for ${filename}; downloaded instead.`);
        }
      }
    } else {
      failed++;
    }

    fallbackDownload(content, filename);
    await new Promise(r => setTimeout(r, 75));
  }

  if (!fallbackOnly && !expired && failed === 0){
    showNotification(`Saved ${saved} map${saved===1?'':'s'} to folder.`);
  } else {
    const total = model.maps.size;
    showNotification(`Downloaded ${total - saved} of ${total} maps — replace them in your folder.`);
  }
}

async function handleReloadMapsClick(){
  try {
    const handle = await ensureDirectoryHandle();
    const previousId = model.current;

    if (handle){
      clearModel();
      const loaded = await loadFromDirectory(handle);
      const nextId = (previousId && model.maps.has(previousId)) ? previousId : model.maps.keys().next().value;
      if (nextId) setCurrent(nextId);
      else model.current = null;
      showNotification(`Reloaded ${loaded} map${loaded===1?'':'s'} from folder.`);
      return;
    }

    await loadInitialMaps();
    showNotification('Reloaded maps from manifest.');
  } catch (err) {
    console.error('Reload failed:', err);
    showNotification('Reload failed — see console for details.');
  }
}

async function loadFromDirectory(handle = directoryHandle) {
  if (!handle) return 0;

  const entries = [];
  try {
    for await (const [name, entry] of handle.entries()){
      if (!name.toLowerCase().endsWith('.toml')) continue;
      const isFile = entry.kind ? entry.kind === 'file' : typeof entry.getFile === 'function';
      if (isFile) entries.push({ name, entry });
    }
  } catch (err) {
    console.error('Error enumerating directory:', err);
    return 0;
  }

  const byId = new Map();
  let duplicates = 0;
  const duplicateNames = [];

  for (const { name, entry } of entries){
    try {
      const file = await entry.getFile();
      const txt = await file.text();
      const obj = fromToml(txt, { filename: name });
      if (!obj.filename) obj.filename = name;
      obj.source = `folder:${name}`;
      const stamp = file.lastModified ?? 0;
      const existing = byId.get(obj.id);
      if (existing){
        duplicates++;
        if (stamp < existing.stamp){
          duplicateNames.push(name);
          staleFolderEntries.add(name);
          continue;
        }
        duplicateNames.push(existing.filename);
        staleFolderEntries.add(existing.filename);
      }
      byId.set(obj.id, { map: obj, stamp, filename: name });
    } catch (err) {
      console.warn(`Failed to load ${name}:`, err);
    }
  }

  for (const { map } of byId.values()){
    model.maps.set(map.id, map);
  }

  if (duplicates > 0){
    console.warn(`[Editor] ${duplicates} duplicate map file(s) detected by id; keeping the newest copy per id.`, duplicateNames);
    showNotification(`Duplicate map files detected — kept the newest copy per map id.`);
  }

  console.log('[Editor] Loaded maps from folder:', Array.from(model.maps.entries()).map(([id, m])=>`${m.name} (${id})`));
  return byId.size;
}

// Auto-discover ./maps/ on page load:
// 1) try maps/manifest.json (["maps/plains.toml", ...])
// 2) else parse the HTML listing at maps/ (works with `npx serve`)
async function loadInitialMaps(){
  clearModel();
  let found = 0;
  const urls = new Set();

  // (1) manifest
  try {
    const r = await fetch('maps/manifest.json');
    if (r.ok){
      const list = await r.json();
      for (const u of list) urls.add(u);
    }
  } catch {}

  // Load
  for (const url of urls){
    try{
      const txt = await (await fetch(url)).text();
      const base = url.split('/').pop() || null;
      const obj = fromToml(txt, { filename: base, source: url });
      if (!obj.filename) obj.filename = base;
      if (!obj.source) obj.source = url;
      model.maps.set(obj.id, obj);
      found++;
    }catch{}
  }
  console.log('[Editor] Loaded maps from manifest:', Array.from(model.maps.entries()).map(([id, m])=>`${m.name} (${id})`));
  if (found > 0){
    const firstId = model.maps.keys().next().value;
    if (firstId) setCurrent(firstId);
  }
  if (!model.current) makeNewMap(); // fallback blank
}

window.addEventListener('DOMContentLoaded', ()=>{ loadInitialMaps(); });


// Painting
let down=false;
cv.addEventListener('pointerdown', e=>{ down=true; paint(e); });
cv.addEventListener('pointermove', e=>{ if (down) paint(e); });
addEventListener('pointerup', ()=> down=false);

function setTool(t){
  tool = t;
  for (const [k,id] of Object.entries(tools)){
    document.getElementById(id).classList.toggle('active', k===t);
  }
}
for (const [k,id] of Object.entries(tools)){ document.getElementById(id).onclick = ()=> setTool(k); }
setTool('wall');

function toCell(e){
  const rect = cv.getBoundingClientRect();
  const px = e.clientX - rect.left, py = e.clientY - rect.top;
  const tw = cv.width / cur().W, th = cv.height / cur().H;
  return { x: Math.floor(px / tw), y: Math.floor(py / th) };
}
function inBounds(x,y){ const m=cur(); return x>=0 && y>=0 && x<m.W && y<m.H; }

function paint(e){
  const m = cur(); const {x,y} = toCell(e); if (!inBounds(x,y)) return;
  if (tool==='wall'){ m.grid[y][x] = m.chars.wall; }
  else if (tool==='erase'){ m.grid[y][x] = m.chars.floor; }
  else if (tool==='spawn'){ m.spawn.x = x; m.spawn.y = y; }
  draw(); syncToml(); validateSpawn(); runLint();
}

// Spawn validation
function validateSpawn(){
  const m = cur();
  const ok = rectIsClear(m, m.spawn.x, m.spawn.y, m.spawn.w, m.spawn.h);
  warn.style.display = ok ? 'none' : 'block';
  warn.textContent = ok ? '' : 'Spawn overlaps walls: ensure a clear area of size Spawn W×H.';
}

// Header / selects
function syncHeader(){
  const m = cur();
  nameIn.value = m.name;
  wIn.value = m.W; hIn.value = m.H; swIn.value = m.spawn.w; shIn.value = m.spawn.h;

  mapsSel.innerHTML = '';
  for (const [id, map] of model.maps.entries()){
    const o = document.createElement('option'); o.value=id; o.textContent=`${map.name} (${id.slice(0,8)})`;
    if (id===model.current) o.selected = true; mapsSel.appendChild(o);
  }
  const opts = [['none','— None —'], ...Array.from(model.maps.entries()).map(([id,m])=>[id, m.name])];
  for (const side of ["left","right","top","bottom"]){
    const sel = edgeSel[side];
    const prev = sel.value;
    sel.innerHTML = '';
    for (const [val,label] of opts){ const o=document.createElement('option'); o.value=val; o.textContent=label; sel.appendChild(o); }
    sel.value = cur().exits[side] ?? 'none';
  }
  validateSpawn();
}

// Keep TOML textarea current
function syncToml(){
  const map = cur();
  currentToml = map ? toToml(map) : '';
  return currentToml;
}

// Render map
function fit(){
  const maxW = Math.min(innerWidth - 24, 1200);
  const aspect = cur().W / cur().H;
  let cw = maxW, ch = Math.round(cw / aspect);
  const maxH = innerHeight * 0.55;
  if (ch > maxH){ ch = Math.round(maxH); cw = Math.round(ch * aspect); }
  cv.width = cw; cv.height = ch;
}
addEventListener('resize', ()=>{ fit(); draw(); });

function draw(){
  const m = cur();
  const tw = cv.width / m.W, th = cv.height / m.H;

  ctx.fillStyle = getCSS('--floor','#fff');
  ctx.fillRect(0,0,cv.width,cv.height);

  const bg = backgroundGrid(m);
  const palette = backgroundPalette(m) || {};
  if (bg){
    for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
      const code = bg[y]?.[x];
      const color = code ? palette[code] : null;
      if (color){
        ctx.fillStyle = color;
        ctx.fillRect(Math.round(x*tw), Math.round(y*th), Math.ceil(tw), Math.ceil(th));
      }
    }
  }

  // grid
  ctx.strokeStyle = getCSS('--grid','#cfd8dc'); ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x=0;x<=m.W;x++){ const px = Math.round(x*tw)+.5; ctx.moveTo(px,0); ctx.lineTo(px,cv.height); }
  for (let y=0;y<=m.H;y++){ const py = Math.round(y*th)+.5; ctx.moveTo(0,py); ctx.lineTo(cv.width,py); }
  ctx.stroke();

  // tiles (draw all cells; spaces show as floor)
  for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
    if (m.grid[y][x]===m.chars.wall){
      ctx.fillStyle = getCSS('--wall','#000');
      ctx.fillRect(Math.round(x*tw), Math.round(y*th), Math.ceil(tw), Math.ceil(th));
    }
  }
  // spawn rectangle
  ctx.fillStyle = getCSS('--spawn','#1976d2');
  ctx.fillRect(Math.round(m.spawn.x*tw), Math.round(m.spawn.y*th), Math.ceil(m.spawn.w*tw), Math.ceil(m.spawn.h*th));
}

// TOML IO — preserve whitespace and blank rows
function toToml(m){
  const lines = m.grid.map(r => r.join("")); // keep trailing spaces by not trimming
  const extras = m.extras ?? makeEmptyExtras();
  const out = [];

  out.push(`id = "${escapeTomlString(m.id)}"`);
  out.push(`name = "${escapeTomlString(m.name)}"`);
  out.push("");

  out.push(`[tiles]`);
  out.push(`wall = "${escapeTomlString(m.chars.wall)}"`);
  out.push(`floor = "${escapeTomlString(m.chars.floor)}"`);
  out.push("");

  out.push(`[spawn]`);
  out.push(`x = ${m.spawn.x}`);
  out.push(`y = ${m.spawn.y}`);
  out.push(`w = ${m.spawn.w}`);
  out.push(`h = ${m.spawn.h}`);
  out.push("");

  if (extras.meta && Object.keys(extras.meta).length){
    out.push(`[meta]`);
    for (const [key, value] of Object.entries(extras.meta)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.legend && Object.keys(extras.legend).length){
    out.push(`[legend]`);
    for (const [key, value] of Object.entries(extras.legend)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.palette && Object.keys(extras.palette).length){
    out.push(`[palette]`);
    for (const [key, value] of Object.entries(extras.palette)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.poi && extras.poi.length){
    for (const entry of extras.poi){
      out.push(`[[poi]]`);
      writeOrderedTable(out, entry, ["id","name","x","y","kind","notes"]);
      out.push("");
    }
  }

  out.push(`grid = """`);
  out.push(...lines);
  out.push(`"""`);
  out.push("");

  if (extras.layers && Object.keys(extras.layers).length){
    for (const [layerName, layer] of Object.entries(extras.layers)){
      if (!layer || typeof layer !== 'object') continue;
      out.push(`[layers.${layerName}]`);
      for (const [key, value] of Object.entries(layer)){
        if (typeof value === 'string' && value.includes("\n")){
          out.push(`${key} = """`);
          out.push(...value.split("\n"));
          out.push(`"""`);
        } else {
          const serialized = formatTomlValue(value);
          if (serialized !== null) out.push(`${key} = ${serialized}`);
        }
      }
      out.push("");
    }
  }

  out.push(`[exits]`);
  if (m.exits.left) out.push(`left = "${escapeTomlString(m.exits.left)}"`);
  if (m.exits.right) out.push(`right = "${escapeTomlString(m.exits.right)}"`);
  if (m.exits.top) out.push(`top = "${escapeTomlString(m.exits.top)}"`);
  if (m.exits.bottom) out.push(`bottom = "${escapeTomlString(m.exits.bottom)}"`);
  out.push("");

  if (extras.triggers && extras.triggers.length){
    for (const entry of extras.triggers){
      out.push(`[[triggers]]`);
      writeOrderedTable(out, entry, ["id","type","event","x","y","w","h","text"]);
      out.push("");
    }
  }

  while (out.length && out[out.length-1] === "") out.pop();
  return out.join("\n") + "\n";
}

function escapeTomlString(str){
  return String(str ?? "").replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function formatTomlValue(value){
  if (value === null || value === undefined) return null;
  if (typeof value === 'number') return Number.isFinite(value) ? String(value) : null;
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  return `"${escapeTomlString(value)}"`;
}

function writeOrderedTable(out, entry, order){
  const seen = new Set();
  for (const key of order){
    if (entry[key] === undefined) continue;
    const serialized = formatTomlValue(entry[key]);
    if (serialized !== null){
      out.push(`${key} = ${serialized}`);
      seen.add(key);
    }
  }
  for (const key of Object.keys(entry)){
    if (seen.has(key)) continue;
    const serialized = formatTomlValue(entry[key]);
    if (serialized !== null) out.push(`${key} = ${serialized}`);
  }
}
function fromToml(txt, meta = {}){
  const t = parseTOML(txt);
  const rows = String(t.grid).replace(/\r\n?/g,"\n").split("\n"); // no trimming
  const H = rows.length, W = Math.max(...rows.map(r=>r.length));
  const grid = Array.from({length:H}, (_,y)=>{
    const line = rows[y] ?? "";
    const padded = line.padEnd(W, (t.tiles?.floor ?? ' '));
    return Array.from({length:W}, (_,x)=> padded[x] ?? (t.tiles?.floor ?? ' '));
  });
  const extras = cloneExtrasFromToml(t);
  return {
    id: t.id, name: t.name || t.id.slice(0,8),
    W, H, grid,
    spawn: { x: t.spawn.x, y: t.spawn.y, w: t.spawn.w, h: t.spawn.h },
    exits: { left: t.exits?.left ?? null, right: t.exits?.right ?? null, top: t.exits?.top ?? null, bottom: t.exits?.bottom ?? null },
    chars: { wall: t.tiles?.wall ?? '#', floor: t.tiles?.floor ?? ' ' },
    extras,
    filename: meta.filename ?? null,
    source: meta.source ?? null
  };
}

function parseTOML(src){
  const out = {};
  let ctx = out;
  let path = [];
  let inML = false, mlKey = "", mlBuf = [], mlTarget = out;

  const isRootKey = k => (k === "id" || k === "name" || k === "grid");
  const set = (obj, key, val) => { obj[key] = val; };

  const shouldForceRoot = (key, path) => {
    if (!isRootKey(key)) return false;
    if (key === "grid"){
      if (path.length === 0) return true;
      if (path.length === 1 && path[0] !== "layers") return true;
      return false;
    }
    return path.length === 0;
  };

  const ensureTable = (segments) => {
    let target = out;
    for (const seg of segments){
      target[seg] ||= {};
      if (typeof target[seg] !== "object" || Array.isArray(target[seg])){
        throw new Error(`TOML: attempted to reuse key '${segments.join('.')}' as non-table.`);
      }
      target = target[seg];
    }
    return target;
  };

  const ensureArrayTable = (segments) => {
    const head = segments.slice(0, -1);
    const leaf = segments[segments.length - 1];
    let target = out;
    for (const seg of head){
      target[seg] ||= {};
      if (typeof target[seg] !== "object" || Array.isArray(target[seg])){
        throw new Error(`TOML: attempted to reuse key '${segments.join('.')}' as non-table.`);
      }
      target = target[seg];
    }
    target[leaf] ||= [];
    if (!Array.isArray(target[leaf])){
      throw new Error(`TOML: key '${segments.join('.')}' already used as non-array.`);
    }
    const obj = {};
    target[leaf].push(obj);
    return obj;
  };

  const lines = src.replace(/\r\n?/g,"\n").split("\n");
  for (let raw of lines){
    const line = raw.trim();

    if (!inML){
      if (!line || line.startsWith("#")) continue;

      let m;
      if ((m = line.match(/^\[\[([A-Za-z0-9_.]+)\]\]$/))){
        const segments = m[1].split('.');
        ctx = ensureArrayTable(segments);
        path = [segments[0]];
        continue;
      }

      if ((m = line.match(/^\[([A-Za-z0-9_.]+)\]$/))){
        const segments = m[1].split('.');
        ctx = ensureTable(segments);
        path = segments;
        continue;
      }

      if ((m = line.match(/^([A-Za-z0-9_]+)\s*=\s*"""$/))){
        const key = m[1];
        inML = true;
        mlKey = key;
        mlBuf = [];
        const forceRoot = shouldForceRoot(key, path);
        mlTarget = forceRoot ? out : ctx;
        if (forceRoot){ ctx = out; path = []; }
        continue;
      }

      if ((m = line.match(/^([A-Za-z0-9_]+)\s*=\s*(.+)$/))){
        const key = m[1];
        let rhs = m[2].trim();
        let val;
        if ((/^".*"$/.test(rhs)) || (/^'.*'$/.test(rhs))){
          val = rhs.slice(1, -1)
            .replace(/\\\\/g, "\\")
            .replace(/\\"/g, '"')
            .replace(/\\n/g, "\n")
            .replace(/\\r/g, "\r")
            .replace(/\\t/g, "\t");
        } else if (/^(true|false)$/i.test(rhs)){
          val = /^true$/i.test(rhs);
        } else if (/^-?\d+$/.test(rhs)){
          val = parseInt(rhs, 10);
        } else if (/^-?\d*\.\d+$/.test(rhs)){
          val = parseFloat(rhs);
        } else {
          throw new Error("Unsupported TOML value: " + rhs);
        }
        const forceRoot = shouldForceRoot(key, path);
        const target = forceRoot ? out : ctx;
        set(target, key, val);
        if (forceRoot){ ctx = out; path = []; }
        continue;
      }

      // Unknown line -> ignore
    } else {
      if (line === `"""`){
        set(mlTarget, mlKey, mlBuf.join("\n"));
        inML = false; mlKey = ""; mlBuf = []; mlTarget = out;
      } else {
        mlBuf.push(raw);
      }
    }
  }
  if (inML) throw new Error("Unterminated multiline string");
  return out;
}



// Lint: dangling and conflicts
function runLint(){
  const problems = [];
  // clear styles
  for (const s of Object.values(edgeSel)) s.classList.remove('bad');

  for (const [id,m] of model.maps.entries()){
    for (const [side,to] of Object.entries(m.exits)){
      if (!to) continue;
      if (!model.maps.has(to)){
        if (id === model.current) edgeSel[side].classList.add('bad');
        problems.push(`Dangling: ${m.name} ${side} → ${to} (missing map)`);
        continue;
      }
      const opp = OPP[side];
      const n = model.maps.get(to);
      if (!n.exits[opp]){
        // auto-reciprocal if empty
        n.exits[opp] = id;
      } else if (n.exits[opp] !== id){
        if (id === model.current) edgeSel[side].classList.add('bad');
        problems.push(`Conflict: ${m.name} ${side} → ${n.name}, but ${n.name} ${opp} → ${short(n.exits[opp])}`);
      }
    }
  }

  if (problems.length){
    warn.classList.remove('ok');
    warn.style.display = 'block';
    warn.textContent = problems.join("\n");
  } else {
    warn.classList.add('ok');
    warn.style.display = 'block';
    warn.textContent = '✓ No link issues';
  }
}

function short(id){
  const m = model.maps.get(id);
  return m ? `${m.name}` : id.slice(0,8);
}

// World overview
// World overview — clickable atlas
const worldCv = document.getElementById('world'), wctx = worldCv.getContext('2d');
let Z=1, pan={x:20,y:20}, dragging=false, last={x:0,y:0};
let worldRects = []; // [{id,x,y,w,h}] in world coords (pre-translate/scale)
let hoverId = null;

document.getElementById('renderWorld').onclick = drawWorld;
document.getElementById('z').oninput = e => { Z=+e.target.value; drawWorld(); };

worldCv.addEventListener('pointerdown', e=>{
  const pt = worldPoint(e);
  // If we clicked a map rect: select it; else begin pan
  const hit = hitTest(pt.x, pt.y);
  if (hit){ setCurrent(hit.id); drawWorld(); return; }
  dragging=true; last={x:e.clientX,y:e.clientY};
});
addEventListener('pointerup', ()=> dragging=false);
addEventListener('pointermove', e=>{
  if (dragging){
    pan.x+=e.clientX-last.x; pan.y+=e.clientY-last.y; last={x:e.clientX,y:e.clientY};
    drawWorld(); return;
  }
  // hover
  const pt = worldPoint(e);
  const hit = hitTest(pt.x, pt.y);
  const nextHover = hit ? hit.id : null;
  if (nextHover !== hoverId){
    hoverId = nextHover;
    worldCv.style.cursor = hoverId ? 'pointer' : 'grab';
    drawWorld();
  }
});

function layout(){
  const pos = new Map(), q = [];
  const DIR = { left:{x:-1,y:0}, right:{x:1,y:0}, top:{x:0,y:-1}, bottom:{x:0,y:1} };
  const start = model.current ?? Array.from(model.maps.keys())[0];
  if (!start) return pos;
  pos.set(start, {x:0,y:0}); q.push(start);
  while(q.length){
    const id = q.shift(), p = pos.get(id), m = model.maps.get(id);
    for (const [side,to] of Object.entries(m.exits)){
      if (!to || !model.maps.has(to)) continue;
      if (!pos.has(to)){
        const d = DIR[side];
        pos.set(to, { x: p.x + d.x, y: p.y + d.y });
        q.push(to);
      }
    }
  }
  return pos;
}

function drawWorld(){
  resizeWorld();
  wctx.clearRect(0,0,worldCv.width,worldCv.height);
  const pos = layout(); wctx.save(); wctx.translate(pan.x, pan.y); wctx.scale(Z,Z);
  const tile = 6;

  worldRects = [];

  // links first
  wctx.strokeStyle="#4b5563"; wctx.lineWidth = 1/Z;
  for (const [id,p] of pos){
    const m = model.maps.get(id); if (!m) continue;
    const A = {x: p.x*(m.W+4)*tile, y: p.y*(m.H+4)*tile, w: m.W*tile, h: m.H*tile};
    for (const [side,to] of Object.entries(m.exits)){
      if (!to || !pos.has(to)) continue;
      const n = model.maps.get(to), q = pos.get(to);
      const B = {x: q.x*(n.W+4)*tile, y: q.y*(n.H+4)*tile, w: n.W*tile, h: n.H*tile};
      wctx.beginPath(); wctx.moveTo(A.x+A.w/2, A.y+A.h/2); wctx.lineTo(B.x+B.w/2, B.y+B.h/2); wctx.stroke();
    }
  }

  // maps
  for (const [id,p] of pos){
    const m = model.maps.get(id); if (!m) continue;
    const ox = p.x*(m.W+4)*tile, oy = p.y*(m.H+4)*tile;
    const rect = { id, x: ox, y: oy, w: m.W*tile, h: m.H*tile };
    worldRects.push(rect);

    // card bg + title
    wctx.fillStyle="#111827"; wctx.fillRect(ox-4, oy-24, m.W*tile+8, m.H*tile+28);
    wctx.fillStyle="#e5e7eb"; wctx.fillText(`${m.name}`, ox, oy-8);

    // map cells
    const worldBg = backgroundGrid(m);
    const worldPalette = backgroundPalette(m) || {};
    if (worldBg){
      for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
        const code = worldBg[y]?.[x];
        const color = code ? worldPalette[code] : null;
        if (color){
          wctx.fillStyle = color;
          wctx.fillRect(ox+x*tile, oy+y*tile, tile, tile);
        } else {
          wctx.fillStyle = "#fff";
          wctx.fillRect(ox+x*tile, oy+y*tile, tile, tile);
        }
      }
    } else {
      for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
        wctx.fillStyle = "#fff";
        wctx.fillRect(ox+x*tile, oy+y*tile, tile, tile);
      }
    }

    for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
      if (m.grid[y][x]===m.chars.wall){
        wctx.fillStyle = "#000";
        wctx.fillRect(ox+x*tile, oy+y*tile, tile, tile);
      }
    }

    // spawn
    wctx.fillStyle="#1976d2";
    wctx.fillRect(ox+m.spawn.x*tile, oy+m.spawn.y*tile, m.spawn.w*tile, m.spawn.h*tile);

    // highlight hover/current
    if (id === hoverId || id === model.current){
      wctx.lineWidth = 2/Z;
      wctx.strokeStyle = (id === model.current) ? "#22c55e" : "#eab308";
      wctx.strokeRect(rect.x-2, rect.y-2, rect.w+4, rect.h+4);
    }
  }

  wctx.restore();
}

function resizeWorld(){ worldCv.width = innerWidth - 24; worldCv.height = Math.round(innerHeight * 0.44); }

function worldPoint(e){
  const r = worldCv.getBoundingClientRect();
  const x = (e.clientX - r.left - pan.x) / Z;
  const y = (e.clientY - r.top  - pan.y) / Z;
  return { x, y };
}
function hitTest(x,y){
  for (let i=worldRects.length-1;i>=0;i--){
    const r = worldRects[i];
    if (x>=r.x && y>=r.y && x<=r.x+r.w && y<=r.y+r.h) return r;
  }
  return null;
}




function rectIsClear(m, x, y, w, h){
  for (let ty=y; ty<y+h; ty++) for (let tx=x; tx<x+w; tx++){
    if (m.grid[ty]?.[tx] === m.chars.wall) return false;
  }
  return true;
}
function getCSS(name, fallback){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback; }
</script>
