<!doctype html>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Level Editor — Edge Exits + TOML</title>
<style>
  :root { --grid:#cfd8dc; --wall:#000; --floor:#fff; --spawn:#1976d2; }
  html,body{height:100%;}
  body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#f6f7fb;color:#223;display:flex;flex-direction:column;min-height:100%;}
  header{position:sticky;top:0;background:#fff;box-shadow:0 1px 0 rgba(0,0,0,.06);z-index:2;padding:8px 12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{display:flex;gap:6px;align-items:center}
  button{padding:6px 10px;border-radius:8px;border:1px solid #c7d0d9;background:#fff;cursor:pointer}
  button.primary{background:#0ea5e9;border-color:#0ea5e9;color:#fff}
  select,input[type=text],input[type=number]{padding:6px;border-radius:8px;border:1px solid #c7d0d9;background:#fff}
  .tool{padding:4px 8px;border:1px solid #c7d0d9;border-radius:6px;user-select:none}
  .tool.active{background:#e0f2fe;border-color:#0ea5e9}
  .banner{padding:8px 12px;background:#fee2e2;color:#7f1d1d;border:1px solid #fecaca;border-radius:8px;margin:8px 0;display:none;white-space:pre-line}
  .ok{background:#dcfce7;color:#14532d;border-color:#bbf7d0}
  .edge{display:flex;gap:6px;align-items:center}
  select.bad{border-color:#ef4444;background:#fee2e2;}
  .muted{color:#6b7280}
  main{flex:1;display:flex;flex-direction:column;min-height:0;}
  #workspace{flex:1;padding:12px;display:flex;box-sizing:border-box;min-height:0;}
  #workspace > section{flex:1;min-width:320px;display:flex;flex-direction:column;gap:12px;min-height:0;}
  #editorPanel{flex:1;position:relative;min-height:0;}
  #atlas{width:100%;height:100%;display:block;background:#0e1118;box-shadow:0 6px 24px rgba(0,0,0,.15);touch-action:none;image-rendering:pixelated;border-radius:12px;cursor:grab;}
  #atlas.grab{cursor:grab;}
  #atlas.grabbing{cursor:grabbing;}
</style>

<header>
  <div class="row">
    <button id="newMap">New Map</button>
    <input id="mapName" type="text" placeholder="Map name"/>
    <label>W<input id="w" type="number" min="4" max="300" value="99"></label>
    <label>H<input id="h" type="number" min="4" max="300" value="70"></label>
    <label>Spawn W<input id="sw" type="number" min="1" max="8" value="2"></label>
    <label>Spawn H<input id="sh" type="number" min="1" max="8" value="2"></label>
    <button id="resize" class="primary">Resize</button>

  <span class="tool" id="paintLine" title="Line (L) - RMB erases">Line (L)</span>
  <span class="tool" id="paintRect" title="Rect (R) - RMB erases">Rect (R)</span>
  <span class="tool" id="paintSpawn" title="3 or P">Spawn (P)</span>

    <select id="maps"></select>
    <button id="makeDefault">Set Default Start</button>
    <button id="saveMaps">Save Maps…</button>
    <button id="reloadMaps">Reload Maps</button>
  <button id="renderWorld">Reset View</button>
  <label><input id="showGrid" type="checkbox" checked>Gridlines</label>
  <label><input id="colorMode" type="checkbox">Edit color</label>
  <label>Color key <input id="colorKey" type="text" value="a" maxlength="2" style="width:40px"></label>
  <label>Color <input id="colorValue" type="color" value="#ffbf47"></label>
  <label>Zoom <input id="z" type="range" min="0.05" max="4" step="0.02" value="0.8"></label>
  </div>

  <div class="row" style="margin-top:6px">
    <div class="edge">Left→   <select id="edge_left"></select></div>
    <div class="edge">Right→  <select id="edge_right"></select></div>
    <div class="edge">Top→    <select id="edge_top"></select></div>
    <div class="edge">Bottom→ <select id="edge_bottom"></select></div>
  </div>

  <div id="warn" class="banner"></div>
</header>

<main id="workspace">
  <section id="editorPanel">
    <canvas id="atlas"></canvas>
  </section>
</main>

<script>
const atlasCv = document.getElementById('atlas'), atlasCtx = atlasCv.getContext('2d');
const zoomInput = document.getElementById('z');
const gridToggle = document.getElementById('showGrid');
const colorModeToggle = document.getElementById('colorMode');
const colorKeyInput = document.getElementById('colorKey');
const colorValueInput = document.getElementById('colorValue');
const resetViewBtn = document.getElementById('renderWorld');
const mapsSel = document.getElementById('maps');
const nameIn = document.getElementById('mapName');
const wIn = document.getElementById('w'), hIn = document.getElementById('h');
const swIn = document.getElementById('sw'), shIn = document.getElementById('sh');
const warn = document.getElementById('warn');
const saveMapsBtn = document.getElementById('saveMaps');
const reloadMapsBtn = document.getElementById('reloadMaps');
const setDefaultBtn = document.getElementById('makeDefault');
let currentToml = '';

const edgeSel = {
  left: document.getElementById('edge_left'),
  right: document.getElementById('edge_right'),
  top: document.getElementById('edge_top'),
  bottom: document.getElementById('edge_bottom'),
};

const tools = { line:'paintLine', rect:'paintRect', spawn:'paintSpawn' };
let tool = 'brush';

const model = {
  maps: new Map(), // id -> {id,name,W,H,grid,spawn:{x,y,w,h}, exits:{left?,right?,top?,bottom?}, chars:{wall,floor}}
  current: null,
  defaultId: null,
  defaultSource: null,
  manifestFiles: []
};
const CH = { wall:'#', floor:' ' };
const staleFolderEntries = new Set();

function slugifyName(name){
  return String(name ?? '')
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g,'_')
    .replace(/^_+|_+$/g,'')
    || 'map';
}

function ensureFilename(map, usedNames){
  if (map.filename){
    if (usedNames) usedNames.add(map.filename);
    return map.filename;
  }
  const base = slugifyName(map.name);
  let candidate = `${base}.toml`;
  let suffix = 2;
  while (usedNames && usedNames.has(candidate)){
    candidate = `${base}_${suffix++}.toml`;
  }
  map.filename = candidate;
  if (usedNames) usedNames.add(candidate);
  return candidate;
}

function makeEmptyExtras(){
  return { meta:null, legend:null, palette:null, layers:null, triggers:[], poi:[] };
}

function cloneExtrasFromToml(t){
  const extras = makeEmptyExtras();
  if (t.meta && typeof t.meta === 'object') extras.meta = { ...t.meta };
  if (t.legend && typeof t.legend === 'object') extras.legend = { ...t.legend };
  if (t.palette && typeof t.palette === 'object') extras.palette = { ...t.palette };
  if (t.layers && typeof t.layers === 'object'){
    extras.layers = {};
    for (const [layerName, layerData] of Object.entries(t.layers)){
      if (!layerData || typeof layerData !== 'object') continue;
      extras.layers[layerName] = {};
      for (const [k, v] of Object.entries(layerData)){
        extras.layers[layerName][k] = (typeof v === 'object' && v !== null)
          ? JSON.parse(JSON.stringify(v))
          : v;
      }
    }
  }
  if (Array.isArray(t.triggers)) extras.triggers = t.triggers.map(entry => ({ ...entry }));
  if (Array.isArray(t.poi)) extras.poi = t.poi.map(entry => ({ ...entry }));
  return extras;
}

function backgroundGrid(map){
  const raw = map?.extras?.layers?.background?.grid;
  if (typeof raw !== 'string') return null;
  const key = `${map.W}x${map.H}:${raw.length}`;
  if (!map._bgCache || map._bgCache.key !== key || map._bgCache.raw !== raw){
    const lines = raw.replace(/\r\n?/g,"\n").split("\n");
    const grid = Array.from({length:map.H}, (_,y)=>{
      const line = lines[y] ?? "";
      const padded = line.padEnd(map.W, ' ');
      return Array.from({length:map.W}, (_,x)=> padded[x] ?? ' ');
    });
    map._bgCache = { key, raw, grid };
  }
  return map._bgCache.grid;
}

function backgroundPalette(map){
  const palette = map?.extras?.palette;
  if (!palette || typeof palette !== 'object') return null;
  if (!map._paletteCache || map._paletteCache.source !== palette){
    map._paletteCache = { source: palette, entries: { ...palette } };
  }
  return map._paletteCache.entries;
}

function ensureBackgroundLayer(map){
  if (!map.extras) map.extras = makeEmptyExtras();
  if (!map.extras.layers || typeof map.extras.layers !== 'object') map.extras.layers = {};
  const layer = map.extras.layers.background;
  if (!layer || typeof layer !== 'object'){
    map.extras.layers.background = {
      grid: Array.from({length:map.H}, ()=>' '.repeat(map.W)).join('\n')
    };
  }
  const bg = map.extras.layers.background;
  if (typeof bg.grid !== 'string'){
    bg.grid = Array.from({length:map.H}, ()=>' '.repeat(map.W)).join('\n');
  }
  return bg;
}

function ensureBackgroundPalette(map){
  if (!map.extras) map.extras = makeEmptyExtras();
  if (!map.extras.palette || typeof map.extras.palette !== 'object') map.extras.palette = {};
  return map.extras.palette;
}

function backgroundGridMatrix(map){
  ensureBackgroundLayer(map);
  const bg = backgroundGrid(map);
  if (bg) return bg;
  const grid = Array.from({length:map.H}, ()=>Array.from({length:map.W}, ()=>' '));
  map._bgCache = { key: `${map.W}x${map.H}:${grid.length}`, raw: grid.map(r=>r.join('')).join('\n'), grid };
  map.extras.layers.background.grid = map._bgCache.raw;
  return map._bgCache.grid;
}

function setBackgroundTile(map, x, y, code){
  if (x<0 || y<0 || x>=map.W || y>=map.H) return false;
  const grid = backgroundGridMatrix(map);
  if (!grid) return false;
  const next = code ?? ' ';
  if (grid[y][x] === next) return false;
  grid[y][x] = next;
  const lines = grid.map(row=>row.join('').slice(0,map.W));
  const serialized = lines.join('\n');
  map.extras.layers.background.grid = serialized;
  map._bgCache = { key: `${map.W}x${map.H}:${serialized.length}`, raw: serialized, grid };
  return true;
}

function resizeBackground(map){
  if (!map || map.W <=0 || map.H <=0) return;
  ensureBackgroundLayer(map);
  const grid = backgroundGridMatrix(map);
  const newRows = Array.from({length:map.H}, (_,y)=>{
    const row = grid[y] || [];
    return Array.from({length:map.W}, (_,x)=> row[x] ?? ' ');
  });
  const serialized = newRows.map(r=>r.join('')).join('\n');
  map.extras.layers.background.grid = serialized;
  map._bgCache = { key: `${map.W}x${map.H}:${serialized.length}`, raw: serialized, grid: newRows };
}

function clearModel(){
  model.maps.clear();
  model.current = null;
  model.defaultId = null;
  model.defaultSource = null;
  model.manifestFiles = [];
  staleFolderEntries.clear();
  atlasInitialized = false;
  mapsSel.innerHTML = '';
  warn.textContent = '';
  warn.style.display = 'none';
  warn.classList.remove('ok');
  if (atlasCtx){
    atlasCtx.setTransform(1,0,0,1,0,0);
    atlasCtx.clearRect(0, 0, atlasCv.width, atlasCv.height);
  }
  console.log('[Editor] Model cleared');
}

function uuid(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
    const r = Math.random()*16|0, v = c=='x' ? r : (r&0x3|0x8); return v.toString(16);
  });
}

function makeNewMap(){
  const id = uuid();
  const data = {
    id, name: `Map ${model.maps.size+1}`,
    W: +wIn.value || 99, H: +hIn.value || 70,
    grid: Array.from({length:+hIn.value||70}, ()=>Array.from({length:+wIn.value||99}, ()=> CH.floor)),
    spawn: {x:1,y:1,w:+swIn.value||2,h:+shIn.value||2},
    exits: {left:null,right:null,top:null,bottom:null},
    chars: {...CH},
    extras: makeEmptyExtras(),
    filename: null,
    source: null
  };
  resizeBackground(data);
  model.maps.set(id, data);
  if (!model.defaultId){
    model.defaultId = id;
    model.defaultSource = data.source;
  }
  atlasInitialized = false;
  setCurrent(id);
}
function setCurrent(id){
  model.current = id;
  if (!model.defaultId || !model.maps.has(model.defaultId)){
    model.defaultId = id;
    const currentMap = model.maps.get(id);
    model.defaultSource = currentMap?.source ?? model.defaultSource;
  }
  syncHeader();
  syncToml();
  validateSpawn();
  runLint();
  atlasState.hoverId = id;
  drawAtlas();
}
function cur(){ return model.maps.get(model.current); }

// ————— Edge helpers —————
const OPP = { left:"right", right:"left", top:"bottom", bottom:"top" };

// When a select changes, set A.side = B, and auto-recursively set B.OPP = A if empty or already pointing to A.
function onEdgeChange(side, toId){
  const A = cur(); // current map
  const oldExit = A.exits[side];
  A.exits[side] = (toId === "none") ? null : toId || null;

  // auto-reciprocal if target exists
  let autoLinked = false;
  if (A.exits[side] && model.maps.has(A.exits[side])){
    const B = model.maps.get(A.exits[side]);
    const opp = OPP[side];
    if (!B.exits[opp] || B.exits[opp] === A.id){
      if (!B.exits[opp]) {
        B.exits[opp] = A.id;
        autoLinked = true;
      }
    }
  }
  
  // Clean up old reciprocal link if we changed the exit
  if (oldExit && oldExit !== A.exits[side] && model.maps.has(oldExit)) {
    const oldB = model.maps.get(oldExit);
    const opp = OPP[side];
    if (oldB.exits[opp] === A.id) {
      oldB.exits[opp] = null;
    }
  }
  
  if (autoLinked) {
    const targetMap = model.maps.get(A.exits[side]);
    showNotification(`Auto-linked ${targetMap.name} ${OPP[side]} → ${A.name}`);
  }
  
  syncHeader();
  syncToml();
  runLint();
  atlasInitialized = false;
  drawAtlas();
}

// UI wiring
document.getElementById('newMap').onclick = makeNewMap;
document.getElementById('resize').onclick = ()=>{
  const m=cur(); m.W=+wIn.value; m.H=+hIn.value;
  m.grid = Array.from({length:m.H}, (_,y)=>Array.from({length:m.W},(_,x)=> (m.grid[y]?.[x] ?? CH.floor)));
  m.spawn.w = +swIn.value; m.spawn.h = +shIn.value;
  resizeBackground(m);
  syncHeader();
  syncToml();
  validateSpawn();
  runLint();
  atlasInitialized = false;
  drawAtlas();
};
mapsSel.onchange = e => setCurrent(e.target.value);
nameIn.onchange = e => {
  cur().name = e.target.value || cur().name;
  syncHeader();
  syncToml();
  runLint();
  drawAtlas();
};

for (const side of ["left","right","top","bottom"]){
  edgeSel[side].onchange = e => onEdgeChange(side, e.target.value);
}

if (setDefaultBtn) setDefaultBtn.onclick = ()=>{
  const m = cur();
  if (!m) return;
  model.defaultId = m.id;
  model.defaultSource = m.source ?? null;
  showNotification(`${m.name} will load first when the game boots.`);
  syncHeader();
  drawAtlas();
};

// Keyboard shortcuts: 1/B = brush, 3 or P=spawn
addEventListener('keydown', e=>{
  const target = e.target;
  const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
  const editable = tag === 'input' || tag === 'textarea' || target?.isContentEditable;
  if (editable) return;
  if (e.key === '1' || e.key.toLowerCase() === 'b') setTool('brush');
  if (e.key === '3' || e.key.toLowerCase() === 'p') setTool('spawn');
  if (e.key.toLowerCase() === 'l') setTool('line');
  if (e.key.toLowerCase() === 'r') setTool('rect');
});

if (saveMapsBtn) saveMapsBtn.onclick = handleSaveMapsClick;
if (reloadMapsBtn) reloadMapsBtn.onclick = handleReloadMapsClick;

async function saveFileToDirectory(handle, filename, content) {
  if (!handle) throw new Error('No directory handle available');

  try {
    console.log(`Attempting to save ${filename}...`);

    try {
      await handle.removeEntry(filename);
      console.log(`Removed existing ${filename}`);
    } catch (removeErr) {
      if (removeErr.name !== 'NotFoundError') {
        console.log(`File ${filename} doesn't exist yet, will create new`);
      } else {
        console.log(`Could not remove ${filename}, will try to overwrite:`, removeErr);
      }
    }

    const fileHandle = await handle.getFileHandle(filename, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    console.log(`✅ Successfully saved ${filename}`);
  } catch (err) {
    console.error(`❌ Failed to save ${filename}:`, err);

    if (err.name === 'InvalidStateError') {
      throw new Error(`Directory handle expired for ${filename}. Please re-select the folder.`);
    }

    if (err.name === 'NotAllowedError') {
      throw new Error(`Permission denied for ${filename}. File may be open elsewhere or access was revoked.`);
    }

    throw err;
  }
}

function fallbackDownload(content, filename) {
  const blob = new Blob([content], {type:'text/plain'});
  const a = document.createElement('a'); 
  a.href = URL.createObjectURL(blob);
  a.download = filename; 
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 100);
}

async function persistManifest(handle, filenames){
  const files = filenames.map(name => `maps/${name}`);
  const payload = { files };

  const defaultMap = (model.defaultId && model.maps.get(model.defaultId)) || null;
  if (defaultMap){
    const file = `maps/${defaultMap.filename}`;
    const info = { id: defaultMap.id, file };
    payload.default = info;
    payload.defaultId = info.id;
    payload.defaultFile = info.file;
    model.defaultSource = info.file;
  }

  model.manifestFiles = files;
  const content = JSON.stringify(payload, null, 2) + '\n';

  if (!handle){
    fallbackDownload(content, 'manifest.json');
    return 'downloaded';
  }

  try {
    await saveFileToDirectory(handle, 'manifest.json', content);
    return 'saved';
  } catch (err) {
    console.error('Failed to save manifest:', err);
    fallbackDownload(content, 'manifest.json');
    return 'downloaded';
  }
}

function showNotification(message) {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 1000;
    background: #22c55e; color: white; padding: 12px 20px;
    border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-weight: 500; animation: fadeInOut 3s ease-in-out;
  `;
  notification.textContent = message;
  
  // Add CSS animation
  if (!document.getElementById('notification-styles')) {
    const style = document.createElement('style');
    style.id = 'notification-styles';
    style.textContent = `
      @keyframes fadeInOut {
        0% { opacity: 0; transform: translateX(100%); }
        15%, 85% { opacity: 1; transform: translateX(0); }
        100% { opacity: 0; transform: translateX(100%); }
      }
    `;
    document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 3000);
}

let directoryHandle = null;

function forgetDirectoryHandle(){ directoryHandle = null; }

async function ensureDirectoryHandle(){
  if (!('showDirectoryPicker' in window)) return null;
  if (directoryHandle) {
    try {
      const status = await directoryHandle.queryPermission?.({ mode: 'readwrite' });
      if (status === 'granted') return directoryHandle;
      if (status === undefined) return directoryHandle;
      if (status === 'denied') {
        forgetDirectoryHandle();
      } else if (status === 'prompt') {
        const granted = await directoryHandle.requestPermission?.({ mode: 'readwrite' });
        if (granted === 'granted') return directoryHandle;
        forgetDirectoryHandle();
      }
    } catch {
      forgetDirectoryHandle();
    }
  }
  try {
    const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
    directoryHandle = handle;
    return handle;
  } catch (err) {
    if (err?.name !== 'AbortError') {
      console.error('Directory selection failed:', err);
      showNotification('Unable to access folder; falling back to downloads.');
    }
    return null;
  }
}

async function handleSaveMapsClick(){
  if (!model.maps.size){
    showNotification('No maps in workspace.');
    return;
  }

  const handle = await ensureDirectoryHandle();
  const fallbackOnly = !handle;
  const usedNames = new Set();
  for (const m of model.maps.values()){
    if (m.filename) usedNames.add(m.filename);
  }
  let saved = 0;
  let failed = 0;
  let expired = false;
  const manifestPaths = [];

  if (handle && staleFolderEntries.size){
    for (const name of Array.from(staleFolderEntries)){
      try {
        await handle.removeEntry(name);
        staleFolderEntries.delete(name);
        console.log(`[Editor] Removed stale duplicate file ${name}`);
      } catch (err) {
        console.warn(`Failed to remove stale file ${name}:`, err);
      }
    }
  }

  for (const map of model.maps.values()){
    const filename = ensureFilename(map, usedNames);
    const content = toToml(map);
    manifestPaths.push(filename);

    if (!fallbackOnly && !expired){
      try {
        await saveFileToDirectory(handle, filename, content);
        map.filename = filename;
        map.source = `maps/${filename}`;
        saved++;
        continue;
      } catch (err) {
        console.error(`Failed to save ${filename}:`, err);
        failed++;
        if (err?.message?.includes('Directory handle expired') || err?.name === 'InvalidStateError'){
          forgetDirectoryHandle();
          expired = true;
          showNotification('Folder access expired — downloading remaining maps.');
        } else {
          showNotification(`Save issue for ${filename}; downloaded instead.`);
        }
      }
    } else {
      failed++;
    }

    fallbackDownload(content, filename);
    await new Promise(r => setTimeout(r, 75));
  }

  const manifestStatus = await persistManifest(!fallbackOnly && !expired ? handle : null, manifestPaths);

  if (!fallbackOnly && !expired && failed === 0 && manifestStatus === 'saved'){
    showNotification(`Saved ${saved} map${saved===1?'':'s'} and manifest to folder.`);
  } else {
    const total = model.maps.size;
    const mapsDownloaded = Math.max(0, total - saved);
    const manifestDownloaded = manifestStatus !== 'saved';
    let msg = '';
    if (mapsDownloaded > 0){
      msg = `Downloaded ${mapsDownloaded} of ${total} maps`;
    }
    if (manifestDownloaded){
      msg += msg ? ' plus manifest.json' : 'Downloaded manifest.json';
    }
    if (!msg) msg = 'Download complete';
    showNotification(`${msg} — replace them in your folder.`);
  }
}

async function handleReloadMapsClick(){
  try {
    const handle = await ensureDirectoryHandle();
    const previousId = model.current;

    if (handle){
      clearModel();
      const loaded = await loadFromDirectory(handle);
      const nextId = (previousId && model.maps.has(previousId)) ? previousId : model.maps.keys().next().value;
      if (nextId) setCurrent(nextId);
      else model.current = null;
      showNotification(`Reloaded ${loaded} map${loaded===1?'':'s'} from folder.`);
      return;
    }

    await loadInitialMaps();
    showNotification('Reloaded maps from manifest.');
  } catch (err) {
    console.error('Reload failed:', err);
    showNotification('Reload failed — see console for details.');
  }
}

async function loadFromDirectory(handle = directoryHandle) {
  if (!handle) return 0;

  atlasInitialized = false;

  const entries = [];
  let manifestInfo = null;
  try {
    for await (const [name, entry] of handle.entries()){
      if (name.toLowerCase() === 'manifest.json'){
        try {
          const manifestFile = await entry.getFile();
          manifestInfo = normalizeManifest(JSON.parse(await manifestFile.text()));
        } catch (err) {
          console.warn('Failed to read manifest.json from folder:', err);
        }
        continue;
      }
      if (!name.toLowerCase().endsWith('.toml')) continue;
      const isFile = entry.kind ? entry.kind === 'file' : typeof entry.getFile === 'function';
      if (isFile) entries.push({ name, entry });
    }
  } catch (err) {
    console.error('Error enumerating directory:', err);
    return 0;
  }

  if (manifestInfo){
    model.defaultSource = manifestInfo.defaultFile ?? null;
    model.defaultId = manifestInfo.defaultId ?? null;
    model.manifestFiles = manifestInfo.files;
  }

  const byId = new Map();
  let duplicates = 0;
  const duplicateNames = [];

  for (const { name, entry } of entries){
    try {
      const file = await entry.getFile();
      const txt = await file.text();
      const obj = fromToml(txt, { filename: name });
      if (!obj.filename) obj.filename = name;
      obj.source = `maps/${name}`;
      if (manifestInfo){
        if (manifestInfo.defaultId && manifestInfo.defaultId === obj.id) model.defaultId = obj.id;
        if (!model.defaultId && manifestInfo.defaultFile && manifestInfo.defaultFile === obj.source) model.defaultId = obj.id;
      }
      const stamp = file.lastModified ?? 0;
      const existing = byId.get(obj.id);
      if (existing){
        duplicates++;
        if (stamp < existing.stamp){
          duplicateNames.push(name);
          staleFolderEntries.add(name);
          continue;
        }
        duplicateNames.push(existing.filename);
        staleFolderEntries.add(existing.filename);
      }
      byId.set(obj.id, { map: obj, stamp, filename: name });
    } catch (err) {
      console.warn(`Failed to load ${name}:`, err);
    }
  }

  const ordered = Array.from(byId.values());
  if (manifestInfo){
    const index = new Map();
    manifestInfo.files.forEach((file, idx) => index.set(file, idx));
    ordered.sort((a, b)=>{
      const ai = index.has(a.map.source) ? index.get(a.map.source) : Number.MAX_SAFE_INTEGER;
      const bi = index.has(b.map.source) ? index.get(b.map.source) : Number.MAX_SAFE_INTEGER;
      return ai - bi;
    });
  }
  for (const { map } of ordered){
    model.maps.set(map.id, map);
  }

  resolveDefaultAfterLoad();

  if (duplicates > 0){
    console.warn(`[Editor] ${duplicates} duplicate map file(s) detected by id; keeping the newest copy per id.`, duplicateNames);
    showNotification(`Duplicate map files detected — kept the newest copy per map id.`);
  }

  console.log('[Editor] Loaded maps from folder:', Array.from(model.maps.entries()).map(([id, m])=>`${m.name} (${id})`));
  drawAtlas();
  return byId.size;
}

function normalizeManifest(raw){
  if (!raw) return null;
  if (Array.isArray(raw)){
    return {
      files: raw.filter(v => typeof v === 'string').map(cleanManifestPath),
      defaultFile: cleanManifestPath(raw.find(v => typeof v === 'string') || null),
      defaultId: null
    };
  }
  if (typeof raw === 'object'){
    const files = Array.isArray(raw.files) ? raw.files.filter(v => typeof v === 'string').map(cleanManifestPath)
      : Array.isArray(raw.maps) ? raw.maps.filter(v => typeof v === 'string').map(cleanManifestPath) : [];
    let defaultFile = null;
    if (typeof raw.defaultFile === 'string') defaultFile = cleanManifestPath(raw.defaultFile);
    else if (raw.default && typeof raw.default === 'string') defaultFile = cleanManifestPath(raw.default);
    else if (raw.default && typeof raw.default.file === 'string') defaultFile = cleanManifestPath(raw.default.file);
    let defaultId = null;
    if (typeof raw.defaultId === 'string') defaultId = raw.defaultId;
    else if (raw.default && typeof raw.default.id === 'string') defaultId = raw.default.id;
    return { files, defaultFile, defaultId };
  }
  return null;
}

function cleanManifestPath(path){
  if (!path) return path;
  return path.replace(/^\.\/?/, '').replace(/\\/g,'/');
}

function resolveDefaultAfterLoad(){
  if (model.defaultId && model.maps.has(model.defaultId)){
    model.defaultSource = model.maps.get(model.defaultId)?.source ?? model.defaultSource;
    return;
  }
  if (model.defaultSource){
    for (const map of model.maps.values()){
      if (map.source === model.defaultSource){
        model.defaultId = map.id;
        model.defaultSource = map.source;
        return;
      }
    }
  }
  const first = model.maps.keys().next().value;
  if (first){
    model.defaultId = first;
    model.defaultSource = model.maps.get(first)?.source ?? model.defaultSource;
  }
}

// Auto-discover ./maps/ on page load:
// 1) try maps/manifest.json (["maps/plains.toml", ...])
// 2) else parse the HTML listing at maps/ (works with `npx serve`)
async function loadInitialMaps(){
  clearModel();
  atlasInitialized = false;
  let found = 0;
  const urls = new Set();
  let manifestInfo = null;

  // (1) manifest
  try {
    const r = await fetch('maps/manifest.json');
    if (r.ok){
      const parsed = normalizeManifest(await r.json());
      if (parsed){
        manifestInfo = parsed;
        for (const u of parsed.files) urls.add(u);
        model.defaultSource = parsed.defaultFile ?? null;
        model.defaultId = parsed.defaultId ?? null;
        model.manifestFiles = parsed.files;
      }
    }
  } catch {}

  // Load
  for (const url of urls){
    try{
      const txt = await (await fetch(url)).text();
      const base = url.split('/').pop() || null;
      const obj = fromToml(txt, { filename: base, source: url });
      if (!obj.filename) obj.filename = base;
      obj.source = `maps/${obj.filename}`;
      if (manifestInfo){
        if (manifestInfo.defaultId && manifestInfo.defaultId === obj.id) model.defaultId = obj.id;
        if (!model.defaultId && manifestInfo.defaultFile && manifestInfo.defaultFile === obj.source) model.defaultId = obj.id;
      }
      model.maps.set(obj.id, obj);
      found++;
    }catch{}
  }
  resolveDefaultAfterLoad();
  console.log('[Editor] Loaded maps from manifest:', Array.from(model.maps.entries()).map(([id, m])=>`${m.name} (${id})`));
  if (found > 0){
    const target = (model.current && model.maps.has(model.current)) ? model.current : model.defaultId;
    if (target) setCurrent(target);
  }
  if (!model.current) makeNewMap(); // fallback blank

  drawAtlas();
}

window.addEventListener('DOMContentLoaded', ()=>{ loadInitialMaps(); });


// Unified atlas editor
const atlasState = {
  zoom: 0.8,
  minZoom: 0.05,
  maxZoom: 4,
  pan: { x: 120, y: 120 },
  pointerMode: null,
  pointerId: null,
  last: { x: 0, y: 0 },
  hoverId: null,
  spacePressed: false,
  worldRects: [],
  baseTile: 28,
  gap: 2,
  cardPadding: 16,
  headerHeight: 28,
  showGrid: true,
  paintButtonMask: 1,
  activePaintTool: null,
  paintStart: null,
  paintPreview: null,
  shapeMode: 'paint',
  colorMode: false,
  activeColorKey: 'a',
  activeColorValue: '#ffbf47'
};
let atlasInitialized = false;

function updateCursor(){
  const isPanning = atlasState.pointerMode === 'pan';
  const hoveringMap = Boolean(atlasState.hoverId);
  atlasCv.classList.toggle('grabbing', isPanning);
  const shouldGrab = !isPanning && (!hoveringMap || atlasState.spacePressed);
  atlasCv.classList.toggle('grab', shouldGrab);
  if (isPanning) return;
  if (!hoveringMap){
    atlasCv.style.cursor = 'grab';
  } else {
    atlasCv.style.cursor = 'pointer';
  }
}

function setTool(t){
  tool = t;
  for (const [k,id] of Object.entries(tools)){
    const el = document.getElementById(id);
    if (el) el.classList.toggle('active', k===t);
  }
  updateCursor();
}
for (const [k,id] of Object.entries(tools)){
  const el = document.getElementById(id);
  if (el) el.onclick = ()=> setTool(tool === k ? 'brush' : k);
}
setTool('brush');

function resizeAtlasCanvas(){
  const rect = atlasCv.getBoundingClientRect();
  const ratio = window.devicePixelRatio || 1;
  const width = Math.max(320, Math.floor(rect.width));
  const height = Math.max(320, Math.floor(rect.height));
  const targetW = Math.round(width * ratio);
  const targetH = Math.round(height * ratio);
  if (atlasCv.width !== targetW || atlasCv.height !== targetH){
    atlasCv.width = targetW;
    atlasCv.height = targetH;
    atlasCtx.setTransform(1,0,0,1,0,0);
    atlasCtx.scale(ratio, ratio);
  }
}

function layout(){
  // Build pixel positions for every map, keeping linked sets cohesive while staging unlinked maps to the side.
  const positions = new Map();
  const queue = [];
  const tile = atlasState.baseTile;
  const gapPx = atlasState.gap * tile;

  let start = null;
  if (model.defaultId && model.maps.has(model.defaultId)) start = model.defaultId;
  else if (model.current && model.maps.has(model.current)) start = model.current;
  else start = Array.from(model.maps.keys())[0];
  if (start && (!model.defaultId || !model.maps.has(model.defaultId))) model.defaultId = start;

  if (start){
    positions.set(start, { x: 0, y: 0 });
  queue.push(start);
  }

  while(queue.length){
    const id = queue.shift();
    const map = model.maps.get(id);
    const origin = positions.get(id);
    if (!map || !origin) continue;
    const width = map.W * tile;
    const height = map.H * tile;

    for (const [side,to] of Object.entries(map.exits)){
      if (!to || !model.maps.has(to) || positions.has(to)) continue;
      const next = model.maps.get(to);
      if (!next) continue;
      const nWidth = next.W * tile;
      const nHeight = next.H * tile;
      let x = origin.x;
      let y = origin.y;
      if (side === 'right'){
        x = origin.x + width + gapPx;
      } else if (side === 'left'){
        x = origin.x - (nWidth + gapPx);
      } else if (side === 'bottom'){
        y = origin.y + height + gapPx;
      } else if (side === 'top'){
        y = origin.y - (nHeight + gapPx);
      }
      positions.set(to, { x, y });
  queue.push(to);
    }
  }

  const unplaced = [];
  for (const id of model.maps.keys()){
    if (!positions.has(id)) unplaced.push(id);
  }

  if (unplaced.length){
    let maxRight = 0;
    for (const [id,pos] of positions.entries()){
      const map = model.maps.get(id);
      if (!map) continue;
      const right = pos.x + map.W * tile;
      if (right > maxRight) maxRight = right;
    }
    const baseX = positions.size ? maxRight + gapPx * 2 : 0;
    let cellW = 0;
    let cellH = 0;
    for (const id of unplaced){
      const map = model.maps.get(id);
      if (!map) continue;
      const w = map.W * tile;
      const h = map.H * tile;
      if (w > cellW) cellW = w;
      if (h > cellH) cellH = h;
    }
    cellW = cellW + gapPx * 2;
    cellH = cellH + gapPx * 2;
    const perColumn = Math.max(1, Math.ceil(Math.sqrt(unplaced.length)));
    let col = 0;
    let row = 0;
    for (const id of unplaced){
      const map = model.maps.get(id);
      if (!map) continue;
      const x = baseX + col * cellW;
      const y = row * cellH;
      positions.set(id, { x, y });
      row++;
      if (row >= perColumn){
        row = 0;
        col++;
      }
    }
  }

  return positions;
}

function drawAtlas(){
  resizeAtlasCanvas();
  atlasCtx.save();
  atlasCtx.setTransform(1,0,0,1,0,0);
  atlasCtx.clearRect(0,0,atlasCv.width, atlasCv.height);
  atlasCtx.restore();

  const positions = layout();
  atlasState.worldRects = [];
  const rectsById = new Map();
  const tile = atlasState.baseTile;
  const pad = atlasState.cardPadding;
  const header = atlasState.headerHeight;
  const floorColor = getCSS('--floor','#fff');
  const gridColor = getCSS('--grid','#cfd8dc');
  const wallColor = getCSS('--wall','#000');
  const spawnColor = getCSS('--spawn','#1976d2');

  atlasCtx.save();
  atlasCtx.translate(atlasState.pan.x, atlasState.pan.y);
  atlasCtx.scale(atlasState.zoom, atlasState.zoom);
  atlasCtx.lineJoin = 'round';
  atlasCtx.lineCap = 'round';
  atlasCtx.font = '16px "Segoe UI", sans-serif';
  atlasCtx.textBaseline = 'top';

  for (const [id,p] of positions){
  const map = model.maps.get(id);
  if (!map) continue;
  const ox = p.x;
  const oy = p.y;
    const rect = {
      id,
      x: ox,
      y: oy,
      w: map.W * tile,
      h: map.H * tile,
      tile
    };
    rectsById.set(id, rect);
    atlasState.worldRects.push(rect);
  }

  const drawnLinks = new Set();
  const linkKey = (a,b)=> a<b ? `${a}|${b}` : `${b}|${a}`;
  atlasCtx.strokeStyle = '#4b5563';
  atlasCtx.lineWidth = Math.max(1/atlasState.zoom, 0.75);
  for (const [id, rect] of rectsById){
    const map = model.maps.get(id);
    if (!map) continue;
    for (const [side,to] of Object.entries(map.exits)){
      if (!to || !rectsById.has(to)) continue;
      const key = linkKey(id,to);
      if (drawnLinks.has(key)) continue;
      drawnLinks.add(key);
      const target = rectsById.get(to);
      atlasCtx.beginPath();
      atlasCtx.moveTo(rect.x + rect.w/2, rect.y + rect.h/2);
      atlasCtx.lineTo(target.x + target.w/2, target.y + target.h/2);
      atlasCtx.stroke();
    }
  }

  for (const [id, rect] of rectsById){
    const map = model.maps.get(id);
    if (!map) continue;
  const cardX = rect.x - pad;
  const cardY = rect.y - (header + 4);
  const cardW = rect.w + pad*2;
  const cardH = rect.h + pad + header + 8;
  const isDefault = id === model.defaultId;
  const title = isDefault ? `${map.name} [default]` : map.name;

    atlasCtx.fillStyle = '#0f172a';
    atlasCtx.fillRect(cardX, cardY, cardW, cardH);
    atlasCtx.fillStyle = '#1f2937';
    atlasCtx.fillRect(cardX, cardY, cardW, header);
    atlasCtx.fillStyle = '#e5e7eb';
  atlasCtx.fillText(title, cardX + 12, cardY + 6);
    atlasCtx.fillStyle = floorColor;
    atlasCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

    const bg = backgroundGrid(map);
    const palette = backgroundPalette(map) || {};
    if (bg){
      for (let y=0;y<map.H;y++){
        for (let x=0;x<map.W;x++){
          const code = bg[y]?.[x];
          const color = code ? palette[code] : null;
          if (!color) continue;
          atlasCtx.fillStyle = color;
          atlasCtx.fillRect(rect.x + x*tile, rect.y + y*tile, tile, tile);
        }
      }
    }

    for (let y=0;y<map.H;y++){
      for (let x=0;x<map.W;x++){
        if (map.grid[y][x] === map.chars.wall){
          atlasCtx.fillStyle = wallColor;
          atlasCtx.fillRect(rect.x + x*tile, rect.y + y*tile, tile, tile);
        }
      }
    }

    if (atlasState.showGrid){
      atlasCtx.strokeStyle = gridColor;
      atlasCtx.lineWidth = Math.max(1/atlasState.zoom, 0.5);
      atlasCtx.beginPath();
      for (let gx=0; gx<=map.W; gx++){
        const px = rect.x + gx*tile;
        atlasCtx.moveTo(px, rect.y);
        atlasCtx.lineTo(px, rect.y + rect.h);
      }
      for (let gy=0; gy<=map.H; gy++){
        const py = rect.y + gy*tile;
        atlasCtx.moveTo(rect.x, py);
        atlasCtx.lineTo(rect.x + rect.w, py);
      }
      atlasCtx.stroke();
    }

    atlasCtx.fillStyle = spawnColor;
    atlasCtx.fillRect(
      rect.x + map.spawn.x * tile,
      rect.y + map.spawn.y * tile,
      map.spawn.w * tile,
      map.spawn.h * tile
    );

    if (id === atlasState.hoverId || id === model.current){
      atlasCtx.lineWidth = Math.max(2/atlasState.zoom, 1);
      atlasCtx.strokeStyle = (id === model.current) ? '#22c55e' : '#eab308';
      atlasCtx.strokeRect(rect.x - 2, rect.y - 2, rect.w + 4, rect.h + 4);
    }

    if (atlasState.paintPreview && atlasState.paintPreview.mapId === id){
      const preview = atlasState.paintPreview;
      const isErase = preview.mode === 'erase';
      const baseColor = isErase ? '#f87171' : (atlasState.colorMode ? atlasState.activeColorValue : '#22c55e');
      atlasCtx.save();
      atlasCtx.globalAlpha = isErase ? 0.25 : 0.35;
      atlasCtx.fillStyle = baseColor;
      if (preview.tool === 'rect'){
        if (isErase){
          const minX = Math.min(preview.start.x, preview.end.x);
          const minY = Math.min(preview.start.y, preview.end.y);
          const width = Math.abs(preview.end.x - preview.start.x) + 1;
          const height = Math.abs(preview.end.y - preview.start.y) + 1;
          atlasCtx.fillRect(rect.x + minX * tile, rect.y + minY * tile, width * tile, height * tile);
        } else {
          const outline = collectRectPoints(preview.start, preview.end, false);
          for (const pt of outline){
            atlasCtx.fillRect(rect.x + pt.x * tile, rect.y + pt.y * tile, tile, tile);
          }
        }
      } else if (preview.tool === 'line'){
        const points = collectLinePoints(preview.start, preview.end);
        for (const pt of points){
          atlasCtx.fillRect(rect.x + pt.x * tile, rect.y + pt.y * tile, tile, tile);
        }
      }
      atlasCtx.restore();
    }
  }

  atlasCtx.restore();

  if (!atlasInitialized && atlasState.worldRects.length){
    centerAtlasOnContent();
    atlasInitialized = true;
    requestAnimationFrame(drawAtlas);
  }
}

function centerAtlasOnContent(){
  if (!atlasState.worldRects.length) return;
  const bounds = atlasState.worldRects.reduce((acc, r)=>{
    const minX = Math.min(acc.minX, r.x);
    const minY = Math.min(acc.minY, r.y);
    const maxX = Math.max(acc.maxX, r.x + r.w);
    const maxY = Math.max(acc.maxY, r.y + r.h);
    return { minX, minY, maxX, maxY };
  }, { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
  if (!isFinite(bounds.minX)) return;
  const rect = atlasCv.getBoundingClientRect();
  const contentW = bounds.maxX - bounds.minX;
  const contentH = bounds.maxY - bounds.minY;
  const margin = 80;
  const viewW = Math.max(320, rect.width - margin);
  const viewH = Math.max(320, rect.height - margin);
  const zoomX = viewW / contentW;
  const zoomY = viewH / contentH;
  const nextZoom = Math.min(atlasState.maxZoom, Math.max(atlasState.minZoom, Math.min(zoomX, zoomY)));
  atlasState.zoom = nextZoom;
  atlasState.pan.x = rect.width/2 - (bounds.minX + contentW/2) * nextZoom;
  atlasState.pan.y = rect.height/2 - (bounds.minY + contentH/2) * nextZoom;
  if (zoomInput) zoomInput.value = nextZoom.toFixed(2);
}

function atlasWorldPoint(e){
  const rect = atlasCv.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left - atlasState.pan.x) / atlasState.zoom,
    y: (e.clientY - rect.top - atlasState.pan.y) / atlasState.zoom,
    screenX: e.clientX - rect.left,
    screenY: e.clientY - rect.top
  };
}

function hitTestAtlas(x,y){
  for (let i=atlasState.worldRects.length-1; i>=0; i--){
    const r = atlasState.worldRects[i];
    if (x>=r.x && y>=r.y && x<=r.x+r.w && y<=r.y+r.h) return r;
  }
  return null;
}

function ensureActiveColorKey(){
  const raw = colorKeyInput?.value ?? atlasState.activeColorKey;
  const sanitized = sanitizeColorKey(raw) || atlasState.activeColorKey;
  atlasState.activeColorKey = sanitized;
  if (colorKeyInput && colorKeyInput.value !== sanitized) colorKeyInput.value = sanitized;
}

function sanitizeColorKey(value){
  const txt = String(value ?? '').trim();
  if (!txt) return '';
  return txt[0];
}

function ensureActivePaletteEntry(map){
  ensureBackgroundPalette(map);
  ensureActiveColorKey();
  const palette = map.extras.palette;
  if (!palette[atlasState.activeColorKey] || palette[atlasState.activeColorKey] !== atlasState.activeColorValue){
    palette[atlasState.activeColorKey] = atlasState.activeColorValue;
    if (map._paletteCache) map._paletteCache = { source: palette, entries: { ...palette } };
  }
}

function paintTile(map, localX, localY, activeTool){
  if (!map) return false;
  if (localX < 0 || localY < 0 || localX >= map.W || localY >= map.H) return false;
  if (atlasState.colorMode){
    ensureBackgroundLayer(map);
    const code = (activeTool === 'erase') ? ' ' : atlasState.activeColorKey;
    if (code !== ' '){
      ensureActivePaletteEntry(map);
    }
    return setBackgroundTile(map, localX, localY, code);
  }
  if (activeTool === 'erase'){
    if (map.grid[localY][localX] === map.chars.floor) return false;
    map.grid[localY][localX] = map.chars.floor;
    return true;
  }
  if (activeTool === 'brush'){
    if (map.grid[localY][localX] === map.chars.wall) return false;
    map.grid[localY][localX] = map.chars.wall;
    return true;
  }
  if (activeTool === 'spawn'){
    if (map.spawn.x === localX && map.spawn.y === localY) return false;
    map.spawn.x = localX;
    map.spawn.y = localY;
    return true;
  }
  return false;
}

function applyPointTool(worldX, worldY, forcedTool = null){
  const hit = hitTestAtlas(worldX, worldY);
  if (!hit) return;
  let map = model.maps.get(hit.id);
  if (!map) return;
  const localX = Math.floor((worldX - hit.x) / hit.tile);
  const localY = Math.floor((worldY - hit.y) / hit.tile);
  const activeTool = forcedTool ?? tool;
  if (atlasState.colorMode && activeTool === 'spawn') return;

  const changed = paintTile(map, localX, localY, activeTool);
  if (!changed) return;

  if (model.current !== map.id){
    setCurrent(map.id);
    map = cur();
    if (!map) return;
    atlasState.hoverId = map.id;
  }

  syncToml();
  if (!atlasState.colorMode || activeTool === 'spawn'){
    validateSpawn();
  }
  runLint();
  drawAtlas();
}

function collectLinePoints(start, end){
  const points = [];
  let x0 = start.x;
  let y0 = start.y;
  let x1 = end.x;
  let y1 = end.y;
  const dx = Math.abs(x1 - x0);
  const dy = Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1;
  const sy = y0 < y1 ? 1 : -1;
  let err = dx - dy;
  while (true){
    points.push({ x: x0, y: y0 });
    if (x0 === x1 && y0 === y1) break;
    const e2 = err * 2;
    if (e2 > -dy){ err -= dy; x0 += sx; }
    if (e2 < dx){ err += dx; y0 += sy; }
  }
  return points;
}

function paintLineBetween(map, start, end, action){
  const points = collectLinePoints(start, end);
  let changed = false;
  if (atlasState.colorMode && action === 'paint') ensureActivePaletteEntry(map);
  for (const pt of points){
    const mode = action === 'erase' ? 'erase' : 'brush';
    changed = paintTile(map, pt.x, pt.y, mode) || changed;
  }
  return changed;
}

function collectRectPoints(start, end, filled){
  const minX = Math.min(start.x, end.x);
  const minY = Math.min(start.y, end.y);
  const maxX = Math.max(start.x, end.x);
  const maxY = Math.max(start.y, end.y);
  const points = [];
  if (filled){
    for (let y=minY; y<=maxY; y++){
      for (let x=minX; x<=maxX; x++){
        points.push({ x, y });
      }
    }
    return points;
  }
  const seen = new Set();
  for (let x=minX; x<=maxX; x++){
    seen.add(`${x},${minY}`);
    seen.add(`${x},${maxY}`);
  }
  for (let y=minY; y<=maxY; y++){
    seen.add(`${minX},${y}`);
    seen.add(`${maxX},${y}`);
  }
  for (const key of seen){
    const [x,y] = key.split(',').map(Number);
    points.push({ x, y });
  }
  return points;
}

function paintRectArea(map, start, end, action){
  const filled = action === 'erase';
  const points = collectRectPoints(start, end, filled);
  let changed = false;
  if (atlasState.colorMode && action === 'paint') ensureActivePaletteEntry(map);
  for (const pt of points){
    const mode = action === 'erase' ? 'erase' : 'brush';
    changed = paintTile(map, pt.x, pt.y, mode) || changed;
  }
  return changed;
}

function commitShape(mapId, activeTool, start, end, mode){
  const map = model.maps.get(mapId);
  if (!map) return false;
  if (!start || !end) return false;
  if (atlasState.colorMode && activeTool === 'spawn') return false;
  let changed = false;
  if (activeTool === 'line'){
    changed = paintLineBetween(map, start, end, mode);
  } else if (activeTool === 'rect'){
    changed = paintRectArea(map, start, end, mode);
  }
  if (!changed) return false;

  if (model.current !== map.id){
    setCurrent(map.id);
    atlasState.hoverId = map.id;
  }

  syncToml();
  if (!atlasState.colorMode) validateSpawn();
  runLint();
  drawAtlas();
  return true;
}

function beginPan(e){
  atlasState.pointerMode = 'pan';
  atlasState.pointerId = e.pointerId;
  atlasState.last = { x: e.clientX, y: e.clientY };
  atlasCv.setPointerCapture(e.pointerId);
  updateCursor();
}

function endPointer(e){
  if (e && atlasState.pointerId !== e.pointerId) return;
  if (atlasState.pointerId !== null){
    try { atlasCv.releasePointerCapture(atlasState.pointerId); } catch {}
  }
  const hadPreview = Boolean(atlasState.paintPreview);
  atlasState.pointerMode = null;
  atlasState.pointerId = null;
  atlasState.activePaintTool = null;
  atlasState.paintButtonMask = 1;
  atlasState.paintStart = null;
  atlasState.paintPreview = null;
  atlasState.shapeMode = 'paint';
  updateCursor();
  if (hadPreview) drawAtlas();
}

function handlePointerDown(e){
  if (!atlasCv.contains(e.target)) return;
  const isMiddle = e.button === 1;
  const isRight = e.button === 2;
  const isSpacePan = atlasState.spacePressed && e.button === 0;
  if (isMiddle || isSpacePan){
    beginPan(e);
    e.preventDefault();
    return;
  }

  const pt = atlasWorldPoint(e);
  const hit = hitTestAtlas(pt.x, pt.y);
  if (isRight){
    if (!hit) return;
    atlasState.hoverId = hit.id;
    if (model.current !== hit.id){
      setCurrent(hit.id);
    }
    const localX = Math.floor((pt.x - hit.x) / hit.tile);
    const localY = Math.floor((pt.y - hit.y) / hit.tile);
    if (tool === 'line' || tool === 'rect'){
      atlasState.pointerMode = 'shape';
      atlasState.pointerId = e.pointerId;
      atlasState.paintButtonMask = 2;
      atlasState.activePaintTool = tool;
      atlasState.paintStart = { mapId: hit.id, x: localX, y: localY };
      atlasState.shapeMode = 'erase';
      atlasState.paintPreview = {
        mapId: hit.id,
        tool,
        mode: 'erase',
        start: { x: localX, y: localY },
        end: { x: localX, y: localY }
      };
      atlasCv.setPointerCapture(e.pointerId);
      drawAtlas();
    } else {
      atlasState.pointerMode = 'paint';
      atlasState.pointerId = e.pointerId;
      atlasState.paintButtonMask = 2;
      atlasState.activePaintTool = 'erase';
      atlasCv.setPointerCapture(e.pointerId);
      applyPointTool(pt.x, pt.y, 'erase');
    }
    e.preventDefault();
    return;
  }

  if (e.button !== 0) return;

  if (!hit){
    beginPan(e);
    e.preventDefault();
    return;
  }

  atlasState.hoverId = hit.id;
  if (model.current !== hit.id){
    setCurrent(hit.id);
  }
  const localX = Math.floor((pt.x - hit.x) / hit.tile);
  const localY = Math.floor((pt.y - hit.y) / hit.tile);
  const activeTool = tool;
  if (activeTool === 'line' || activeTool === 'rect'){
    atlasState.pointerMode = 'shape';
    atlasState.paintStart = { mapId: hit.id, x: localX, y: localY };
    atlasState.paintPreview = {
      mapId: hit.id,
      tool: activeTool,
      mode: 'paint',
      start: { x: localX, y: localY },
      end: { x: localX, y: localY }
    };
    atlasState.pointerId = e.pointerId;
    atlasState.paintButtonMask = 1;
    atlasState.activePaintTool = activeTool;
    atlasState.shapeMode = 'paint';
    atlasCv.setPointerCapture(e.pointerId);
    drawAtlas();
    e.preventDefault();
    return;
  }
  atlasState.pointerMode = 'paint';
  atlasState.pointerId = e.pointerId;
  atlasState.paintButtonMask = 1;
  atlasState.activePaintTool = null;
  atlasCv.setPointerCapture(e.pointerId);
  applyPointTool(pt.x, pt.y, atlasState.activePaintTool);
  e.preventDefault();
}

function handlePointerMove(e){
  if (atlasState.pointerId === e.pointerId){
    if (atlasState.pointerMode === 'pan'){
      const dx = e.clientX - atlasState.last.x;
      const dy = e.clientY - atlasState.last.y;
      atlasState.pan.x += dx;
      atlasState.pan.y += dy;
      atlasState.last = { x: e.clientX, y: e.clientY };
      drawAtlas();
      e.preventDefault();
      return;
    }
    if (atlasState.pointerMode === 'shape'){
      const mask = atlasState.paintButtonMask || 1;
      if ((e.buttons & mask) === 0){
        endPointer(e);
        return;
      }
      const pt = atlasWorldPoint(e);
      const hit = hitTestAtlas(pt.x, pt.y);
      if (!hit || hit.id !== atlasState.paintStart?.mapId){
        atlasState.paintPreview = null;
        drawAtlas();
        return;
      }
      const localX = Math.floor((pt.x - hit.x) / hit.tile);
      const localY = Math.floor((pt.y - hit.y) / hit.tile);
      atlasState.paintPreview = {
        mapId: hit.id,
        tool: atlasState.activePaintTool,
        mode: atlasState.shapeMode,
        start: { x: atlasState.paintStart.x, y: atlasState.paintStart.y },
        end: { x: localX, y: localY }
      };
      drawAtlas();
      e.preventDefault();
      return;
    }
    if (atlasState.pointerMode === 'paint'){
      const mask = atlasState.paintButtonMask || 1;
      if ((e.buttons & mask) === 0){
        endPointer(e);
        return;
      }
      const pt = atlasWorldPoint(e);
      applyPointTool(pt.x, pt.y, atlasState.activePaintTool);
      e.preventDefault();
      return;
    }
  }

  if (atlasState.pointerMode === null){
    const pt = atlasWorldPoint(e);
    const hit = hitTestAtlas(pt.x, pt.y);
    const nextHover = hit ? hit.id : null;
    if (nextHover !== atlasState.hoverId){
      atlasState.hoverId = nextHover;
      updateCursor();
      drawAtlas();
    }
  }
}

function handlePointerUp(e){
  if (atlasState.pointerId === e.pointerId){
    if (atlasState.pointerMode === 'shape' && atlasState.paintPreview){
      const preview = atlasState.paintPreview;
      commitShape(preview.mapId, preview.tool, preview.start, preview.end, preview.mode || 'paint');
    }
    endPointer(e);
  }
}

function setZoom(nextZoom, pivot){
  const clamped = Math.min(atlasState.maxZoom, Math.max(atlasState.minZoom, nextZoom));
  const prevZoom = atlasState.zoom;
  if (Math.abs(prevZoom - clamped) < 1e-4) return;
  let world;
  let screen;
  if (pivot && pivot.world && pivot.screen){
    world = pivot.world;
    screen = pivot.screen;
  } else {
    const rect = atlasCv.getBoundingClientRect();
    world = {
      x: (rect.width / 2 - atlasState.pan.x) / prevZoom,
      y: (rect.height / 2 - atlasState.pan.y) / prevZoom
    };
    screen = { x: rect.width / 2, y: rect.height / 2 };
  }
  atlasState.zoom = clamped;
  atlasState.pan.x = screen.x - world.x * clamped;
  atlasState.pan.y = screen.y - world.y * clamped;
  if (zoomInput) zoomInput.value = clamped.toFixed(2);
  drawAtlas();
}

function handleWheel(e){
  e.preventDefault();
  const delta = -e.deltaY;
  const scale = Math.exp(delta * 0.0015);
  const nextZoom = atlasState.zoom * scale;
  const pt = atlasWorldPoint(e);
  setZoom(nextZoom, { world: { x: pt.x, y: pt.y }, screen: { x: pt.screenX, y: pt.screenY } });
}

function resetAtlasView(){
  atlasInitialized = false;
  drawAtlas();
}

atlasCv.addEventListener('pointerdown', handlePointerDown);
atlasCv.addEventListener('pointermove', handlePointerMove);
addEventListener('pointerup', handlePointerUp);
addEventListener('pointercancel', handlePointerUp);
atlasCv.addEventListener('pointerleave', e=>{
  if (atlasState.pointerMode === null){
    atlasState.hoverId = null;
    updateCursor();
    drawAtlas();
  }
});
atlasCv.addEventListener('wheel', handleWheel, { passive:false });
atlasCv.addEventListener('contextmenu', e=> e.preventDefault());

if (zoomInput){
  zoomInput.value = atlasState.zoom.toFixed(2);
  zoomInput.addEventListener('input', e=>{
    const next = parseFloat(e.target.value);
    if (!Number.isFinite(next)) return;
    setZoom(next);
    atlasInitialized = true;
  });
}

if (gridToggle){
  atlasState.showGrid = gridToggle.checked;
  gridToggle.addEventListener('change', e=>{
    atlasState.showGrid = e.target.checked;
    drawAtlas();
  });
}

if (colorModeToggle){
  atlasState.colorMode = colorModeToggle.checked;
  colorModeToggle.addEventListener('change', e=>{
    atlasState.colorMode = e.target.checked;
    atlasState.paintPreview = null;
    drawAtlas();
  });
}

if (colorValueInput){
  atlasState.activeColorValue = colorValueInput.value || atlasState.activeColorValue;
  colorValueInput.addEventListener('input', e=>{
    atlasState.activeColorValue = e.target.value || '#ffffff';
  });
}

if (colorKeyInput){
  ensureActiveColorKey();
  colorKeyInput.addEventListener('input', e=>{
    const sanitized = sanitizeColorKey(e.target.value) || atlasState.activeColorKey;
    atlasState.activeColorKey = sanitized;
    if (e.target.value !== sanitized) e.target.value = sanitized;
  });
}

if (resetViewBtn){
  resetViewBtn.onclick = ()=> resetAtlasView();
}

addEventListener('keydown', e=>{
  if (e.code === 'Space' && !e.repeat){
    const target = e.target;
    const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
    const editable = tag === 'input' || tag === 'textarea' || target?.isContentEditable;
    if (editable) return;
    atlasState.spacePressed = true;
    updateCursor();
    e.preventDefault();
  }
});
addEventListener('keyup', e=>{
  if (e.code === 'Space'){
    atlasState.spacePressed = false;
    if (atlasState.pointerMode !== 'pan') updateCursor();
  }
});

addEventListener('resize', ()=>{
  atlasInitialized = false;
  drawAtlas();
});

// Spawn validation
function validateSpawn(){
  const m = cur();
  const ok = rectIsClear(m, m.spawn.x, m.spawn.y, m.spawn.w, m.spawn.h);
  warn.style.display = ok ? 'none' : 'block';
  warn.textContent = ok ? '' : 'Spawn overlaps walls: ensure a clear area of size Spawn W×H.';
}

// Header / selects
function syncHeader(){
  const m = cur();
  if (!m) return;
  nameIn.value = m.name;
  wIn.value = m.W; hIn.value = m.H; swIn.value = m.spawn.w; shIn.value = m.spawn.h;

  mapsSel.innerHTML = '';
  for (const [id, map] of model.maps.entries()){
    const isDefault = id === model.defaultId;
    const o = document.createElement('option');
    o.value = id;
  const suffix = isDefault ? ` (default · ${id.slice(0,8)})` : ` (${id.slice(0,8)})`;
    o.textContent = `${map.name}${suffix}`;
    if (id===model.current) o.selected = true;
    mapsSel.appendChild(o);
  }
  if (setDefaultBtn) setDefaultBtn.disabled = (m.id === model.defaultId);

  const opts = [['none','— None —'], ...Array.from(model.maps.entries()).map(([id,m])=>[id, m.name])];
  for (const side of ["left","right","top","bottom"]){
    const sel = edgeSel[side];
    const prev = sel.value;
    sel.innerHTML = '';
    for (const [val,label] of opts){ const o=document.createElement('option'); o.value=val; o.textContent=label; sel.appendChild(o); }
    sel.value = cur().exits[side] ?? 'none';
  }
  validateSpawn();
}

// Keep TOML textarea current
function syncToml(){
  const map = cur();
  currentToml = map ? toToml(map) : '';
  return currentToml;
}

// TOML IO — preserve whitespace and blank rows
function toToml(m){
  const lines = m.grid.map(r => r.join("")); // keep trailing spaces by not trimming
  const extras = m.extras ?? makeEmptyExtras();
  const out = [];

  out.push(`id = "${escapeTomlString(m.id)}"`);
  out.push(`name = "${escapeTomlString(m.name)}"`);
  out.push("");

  out.push(`[tiles]`);
  out.push(`wall = "${escapeTomlString(m.chars.wall)}"`);
  out.push(`floor = "${escapeTomlString(m.chars.floor)}"`);
  out.push("");

  out.push(`[spawn]`);
  out.push(`x = ${m.spawn.x}`);
  out.push(`y = ${m.spawn.y}`);
  out.push(`w = ${m.spawn.w}`);
  out.push(`h = ${m.spawn.h}`);
  out.push("");

  if (extras.meta && Object.keys(extras.meta).length){
    out.push(`[meta]`);
    for (const [key, value] of Object.entries(extras.meta)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.legend && Object.keys(extras.legend).length){
    out.push(`[legend]`);
    for (const [key, value] of Object.entries(extras.legend)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.palette && Object.keys(extras.palette).length){
    out.push(`[palette]`);
    for (const [key, value] of Object.entries(extras.palette)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.poi && extras.poi.length){
    for (const entry of extras.poi){
      out.push(`[[poi]]`);
      writeOrderedTable(out, entry, ["id","name","x","y","kind","notes"]);
      out.push("");
    }
  }

  out.push(`grid = """`);
  out.push(...lines);
  out.push(`"""`);
  out.push("");

  if (extras.layers && Object.keys(extras.layers).length){
    for (const [layerName, layer] of Object.entries(extras.layers)){
      if (!layer || typeof layer !== 'object') continue;
      out.push(`[layers.${layerName}]`);
      for (const [key, value] of Object.entries(layer)){
        if (typeof value === 'string' && value.includes("\n")){
          out.push(`${key} = """`);
          out.push(...value.split("\n"));
          out.push(`"""`);
        } else {
          const serialized = formatTomlValue(value);
          if (serialized !== null) out.push(`${key} = ${serialized}`);
        }
      }
      out.push("");
    }
  }

  out.push(`[exits]`);
  if (m.exits.left) out.push(`left = "${escapeTomlString(m.exits.left)}"`);
  if (m.exits.right) out.push(`right = "${escapeTomlString(m.exits.right)}"`);
  if (m.exits.top) out.push(`top = "${escapeTomlString(m.exits.top)}"`);
  if (m.exits.bottom) out.push(`bottom = "${escapeTomlString(m.exits.bottom)}"`);
  out.push("");

  if (extras.triggers && extras.triggers.length){
    for (const entry of extras.triggers){
      out.push(`[[triggers]]`);
      writeOrderedTable(out, entry, ["id","type","event","x","y","w","h","text"]);
      out.push("");
    }
  }

  while (out.length && out[out.length-1] === "") out.pop();
  return out.join("\n") + "\n";
}

function escapeTomlString(str){
  return String(str ?? "").replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function formatTomlValue(value){
  if (value === null || value === undefined) return null;
  if (typeof value === 'number') return Number.isFinite(value) ? String(value) : null;
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  return `"${escapeTomlString(value)}"`;
}

function writeOrderedTable(out, entry, order){
  const seen = new Set();
  for (const key of order){
    if (entry[key] === undefined) continue;
    const serialized = formatTomlValue(entry[key]);
    if (serialized !== null){
      out.push(`${key} = ${serialized}`);
      seen.add(key);
    }
  }
  for (const key of Object.keys(entry)){
    if (seen.has(key)) continue;
    const serialized = formatTomlValue(entry[key]);
    if (serialized !== null) out.push(`${key} = ${serialized}`);
  }
}
function fromToml(txt, meta = {}){
  const t = parseTOML(txt);
  const rows = String(t.grid).replace(/\r\n?/g,"\n").split("\n"); // no trimming
  const H = rows.length, W = Math.max(...rows.map(r=>r.length));
  const grid = Array.from({length:H}, (_,y)=>{
    const line = rows[y] ?? "";
    const padded = line.padEnd(W, (t.tiles?.floor ?? ' '));
    return Array.from({length:W}, (_,x)=> padded[x] ?? (t.tiles?.floor ?? ' '));
  });
  const extras = cloneExtrasFromToml(t);
  const map = {
    id: t.id, name: t.name || t.id.slice(0,8),
    W, H, grid,
    spawn: { x: t.spawn.x, y: t.spawn.y, w: t.spawn.w, h: t.spawn.h },
    exits: { left: t.exits?.left ?? null, right: t.exits?.right ?? null, top: t.exits?.top ?? null, bottom: t.exits?.bottom ?? null },
    chars: { wall: t.tiles?.wall ?? '#', floor: t.tiles?.floor ?? ' ' },
    extras,
    filename: meta.filename ?? null,
    source: meta.source ?? null
  };
  resizeBackground(map);
  return map;
}

function parseTOML(src){
  const out = {};
  let ctx = out;
  let path = [];
  let inML = false, mlKey = "", mlBuf = [], mlTarget = out;

  const isRootKey = k => (k === "id" || k === "name" || k === "grid");
  const set = (obj, key, val) => { obj[key] = val; };

  const shouldForceRoot = (key, path) => {
    if (!isRootKey(key)) return false;
    if (key === "grid"){
      if (path.length === 0) return true;
      if (path.length === 1 && path[0] !== "layers") return true;
      return false;
    }
    return path.length === 0;
  };

  const ensureTable = (segments) => {
    let target = out;
    for (const seg of segments){
      target[seg] ||= {};
      if (typeof target[seg] !== "object" || Array.isArray(target[seg])){
        throw new Error(`TOML: attempted to reuse key '${segments.join('.')}' as non-table.`);
      }
      target = target[seg];
    }
    return target;
  };

  const ensureArrayTable = (segments) => {
    const head = segments.slice(0, -1);
    const leaf = segments[segments.length - 1];
    let target = out;
    for (const seg of head){
      target[seg] ||= {};
      if (typeof target[seg] !== "object" || Array.isArray(target[seg])){
        throw new Error(`TOML: attempted to reuse key '${segments.join('.')}' as non-table.`);
      }
      target = target[seg];
    }
    target[leaf] ||= [];
    if (!Array.isArray(target[leaf])){
      throw new Error(`TOML: key '${segments.join('.')}' already used as non-array.`);
    }
    const obj = {};
    target[leaf].push(obj);
    return obj;
  };

  const lines = src.replace(/\r\n?/g,"\n").split("\n");
  for (let raw of lines){
    const line = raw.trim();

    if (!inML){
      if (!line || line.startsWith("#")) continue;

      let m;
      if ((m = line.match(/^\[\[([A-Za-z0-9_.]+)\]\]$/))){
        const segments = m[1].split('.');
        ctx = ensureArrayTable(segments);
        path = [segments[0]];
        continue;
      }

      if ((m = line.match(/^\[([A-Za-z0-9_.]+)\]$/))){
        const segments = m[1].split('.');
        ctx = ensureTable(segments);
        path = segments;
        continue;
      }

      if ((m = line.match(/^([A-Za-z0-9_]+)\s*=\s*"""$/))){
        const key = m[1];
        inML = true;
        mlKey = key;
        mlBuf = [];
        const forceRoot = shouldForceRoot(key, path);
        mlTarget = forceRoot ? out : ctx;
        if (forceRoot){ ctx = out; path = []; }
        continue;
      }

      if ((m = line.match(/^([A-Za-z0-9_]+)\s*=\s*(.+)$/))){
        const key = m[1];
        let rhs = m[2].trim();
        let val;
        if ((/^".*"$/.test(rhs)) || (/^'.*'$/.test(rhs))){
          val = rhs.slice(1, -1)
            .replace(/\\\\/g, "\\")
            .replace(/\\"/g, '"')
            .replace(/\\n/g, "\n")
            .replace(/\\r/g, "\r")
            .replace(/\\t/g, "\t");
        } else if (/^(true|false)$/i.test(rhs)){
          val = /^true$/i.test(rhs);
        } else if (/^-?\d+$/.test(rhs)){
          val = parseInt(rhs, 10);
        } else if (/^-?\d*\.\d+$/.test(rhs)){
          val = parseFloat(rhs);
        } else {
          throw new Error("Unsupported TOML value: " + rhs);
        }
        const forceRoot = shouldForceRoot(key, path);
        const target = forceRoot ? out : ctx;
        set(target, key, val);
        if (forceRoot){ ctx = out; path = []; }
        continue;
      }

      // Unknown line -> ignore
    } else {
      if (line === `"""`){
        set(mlTarget, mlKey, mlBuf.join("\n"));
        inML = false; mlKey = ""; mlBuf = []; mlTarget = out;
      } else {
        mlBuf.push(raw);
      }
    }
  }
  if (inML) throw new Error("Unterminated multiline string");
  return out;
}



// Lint: dangling and conflicts
function runLint(){
  const problems = [];
  // clear styles
  for (const s of Object.values(edgeSel)) s.classList.remove('bad');

  for (const [id,m] of model.maps.entries()){
    for (const [side,to] of Object.entries(m.exits)){
      if (!to) continue;
      if (!model.maps.has(to)){
        if (id === model.current) edgeSel[side].classList.add('bad');
        problems.push(`Dangling: ${m.name} ${side} → ${to} (missing map)`);
        continue;
      }
      const opp = OPP[side];
      const n = model.maps.get(to);
      if (!n.exits[opp]){
        // auto-reciprocal if empty
        n.exits[opp] = id;
      } else if (n.exits[opp] !== id){
        if (id === model.current) edgeSel[side].classList.add('bad');
        problems.push(`Conflict: ${m.name} ${side} → ${n.name}, but ${n.name} ${opp} → ${short(n.exits[opp])}`);
      }
    }
  }

  if (problems.length){
    warn.classList.remove('ok');
    warn.style.display = 'block';
    warn.textContent = problems.join("\n");
  } else {
    warn.classList.add('ok');
    warn.style.display = 'block';
    warn.textContent = '✓ No link issues';
  }
}

function short(id){
  const m = model.maps.get(id);
  return m ? `${m.name}` : id.slice(0,8);
}


function rectIsClear(m, x, y, w, h){
  for (let ty=y; ty<y+h; ty++) for (let tx=x; tx<x+w; tx++){
    if (m.grid[ty]?.[tx] === m.chars.wall) return false;
  }
  return true;
}
function getCSS(name, fallback){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback; }
</script>
