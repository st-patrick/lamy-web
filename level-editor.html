<!doctype html>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Level Editor â€” Edge Exits + TOML</title>
<style>
  :root { --grid:#cfd8dc; --wall:#000; --floor:#fff; --spawn:#1976d2; }
  body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#f6f7fb;color:#223}
  header{position:sticky;top:0;background:#fff;box-shadow:0 1px 0 rgba(0,0,0,.06);z-index:2;padding:8px 12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{display:flex;gap:6px;align-items:center}
  button{padding:6px 10px;border-radius:8px;border:1px solid #c7d0d9;background:#fff;cursor:pointer}
  button.primary{background:#0ea5e9;border-color:#0ea5e9;color:#fff}
  select,input[type=text],input[type=number]{padding:6px;border-radius:8px;border:1px solid #c7d0d9;background:#fff}
  .tool{padding:4px 8px;border:1px solid #c7d0d9;border-radius:6px;user-select:none}
  .tool.active{background:#e0f2fe;border-color:#0ea5e9}
  #cv{background:var(--floor);image-rendering:pixelated;box-shadow:0 6px 24px rgba(0,0,0,.1);touch-action:none}
  .banner{padding:8px 12px;background:#fee2e2;color:#7f1d1d;border:1px solid #fecaca;border-radius:8px;margin:8px 0;display:none;white-space:pre-line}
  .ok{background:#dcfce7;color:#14532d;border-color:#bbf7d0}
  textarea{width:100%;min-height:120px}
  #world{width:100%;height:44vh;background:#0e1118;box-shadow:0 6px 24px rgba(0,0,0,.15);cursor:grab}
  #world:active{cursor:grabbing}
  .edge{display:flex;gap:6px;align-items:center}
  select.bad{border-color:#ef4444; background:#fee2e2;}
  .muted{color:#6b7280}
</style>

<header>
  <div class="row">
    <button id="newMap">New Map</button>
    <input id="mapName" type="text" placeholder="Map name"/>
    <label>W<input id="w" type="number" min="4" max="300" value="99"></label>
    <label>H<input id="h" type="number" min="4" max="300" value="70"></label>
    <label>Spawn W<input id="sw" type="number" min="1" max="8" value="2"></label>
    <label>Spawn H<input id="sh" type="number" min="1" max="8" value="2"></label>
    <button id="resize" class="primary">Resize</button>

    <span class="tool" id="paintWall" title="1">Wall (#)</span>
    <span class="tool" id="paintErase" title="2">Erase ( )</span>
    <span class="tool" id="paintSpawn" title="3 or P">Spawn (P)</span>

    <select id="maps"></select>
    <button id="exportBtn">Export TOML</button>
    <button id="exportAllBtn">Export All</button>
    <label><input id="importFiles" type="file" multiple accept=".toml"/> Load TOML(s)</label>
    <button id="openFolder" style="display:none">Open Folderâ€¦</button>
    <button id="refreshFolder" style="display:none">Refresh Folder</button>
    <button id="requestPersistent" style="display:none">Grant Persistent Access</button>
    <button id="testSave" style="display:none">Test Save</button>
    <button id="clearStorage" style="display:none">Reset Cache</button>
    <span id="fsHint" class="muted"></span>
  </div>

  <div class="row" style="margin-top:6px">
    <div class="edge">Leftâ†’   <select id="edge_left"></select></div>
    <div class="edge">Rightâ†’  <select id="edge_right"></select></div>
    <div class="edge">Topâ†’    <select id="edge_top"></select></div>
    <div class="edge">Bottomâ†’ <select id="edge_bottom"></select></div>
  </div>

  <div id="warn" class="banner"></div>
</header>

<main style="padding:12px;display:grid;gap:12px">
  <canvas id="cv" width="960" height="540"></canvas>

  <section>
    <strong>Current map TOML</strong>
    <textarea id="toml"></textarea>
  </section>

  <section>
    <div class="row"><button id="renderWorld">World Overview</button>
      <label>Zoom <input id="z" type="range" min="0.2" max="4" step="0.05" value="1"></label>
    </div>
    <canvas id="world"></canvas>
  </section>
</main>

<script>
const cv = document.getElementById('cv'), ctx = cv.getContext('2d');
const mapsSel = document.getElementById('maps');
const nameIn = document.getElementById('mapName');
const wIn = document.getElementById('w'), hIn = document.getElementById('h');
const swIn = document.getElementById('sw'), shIn = document.getElementById('sh');
const warn = document.getElementById('warn');
const tomlArea = document.getElementById('toml');

const edgeSel = {
  left: document.getElementById('edge_left'),
  right: document.getElementById('edge_right'),
  top: document.getElementById('edge_top'),
  bottom: document.getElementById('edge_bottom'),
};

const tools = { wall:'paintWall', erase:'paintErase', spawn:'paintSpawn' };
let tool = 'wall';

const model = {
  maps: new Map(), // id -> {id,name,W,H,grid,spawn:{x,y,w,h}, exits:{left?,right?,top?,bottom?}, chars:{wall,floor}}
  current: null
};
const CH = { wall:'#', floor:' ' };

function makeEmptyExtras(){
  return { meta:null, legend:null, palette:null, layers:null, triggers:[], poi:[] };
}

function cloneExtrasFromToml(t){
  const extras = makeEmptyExtras();
  if (t.meta && typeof t.meta === 'object') extras.meta = { ...t.meta };
  if (t.legend && typeof t.legend === 'object') extras.legend = { ...t.legend };
  if (t.palette && typeof t.palette === 'object') extras.palette = { ...t.palette };
  if (t.layers && typeof t.layers === 'object'){
    extras.layers = {};
    for (const [layerName, layerData] of Object.entries(t.layers)){
      if (!layerData || typeof layerData !== 'object') continue;
      extras.layers[layerName] = {};
      for (const [k, v] of Object.entries(layerData)){
        extras.layers[layerName][k] = (typeof v === 'object' && v !== null)
          ? JSON.parse(JSON.stringify(v))
          : v;
      }
    }
  }
  if (Array.isArray(t.triggers)) extras.triggers = t.triggers.map(entry => ({ ...entry }));
  if (Array.isArray(t.poi)) extras.poi = t.poi.map(entry => ({ ...entry }));
  return extras;
}

function clearModel(){
  model.maps.clear();
  model.current = null;
  mapsSel.innerHTML = '';
  tomlArea.value = '';
  warn.textContent = '';
  warn.style.display = 'none';
  warn.classList.remove('ok');
  ctx.clearRect(0, 0, cv.width, cv.height);
  console.log('[Editor] Model cleared');
}

function uuid(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
    const r = Math.random()*16|0, v = c=='x' ? r : (r&0x3|0x8); return v.toString(16);
  });
}

function makeNewMap(){
  const id = uuid();
  const data = {
    id, name: `Map ${model.maps.size+1}`,
    W: +wIn.value || 99, H: +hIn.value || 70,
    grid: Array.from({length:+hIn.value||70}, ()=>Array.from({length:+wIn.value||99}, ()=> CH.floor)),
    spawn: {x:1,y:1,w:+swIn.value||2,h:+shIn.value||2},
    exits: {left:null,right:null,top:null,bottom:null},
    chars: {...CH},
    extras: makeEmptyExtras()
  };
  model.maps.set(id, data);
  setCurrent(id);
}
function setCurrent(id){
  model.current = id;
  syncHeader();
  fit(); draw(); syncToml(); runLint();
}
function cur(){ return model.maps.get(model.current); }

// â€”â€”â€”â€”â€” Edge helpers â€”â€”â€”â€”â€”
const OPP = { left:"right", right:"left", top:"bottom", bottom:"top" };

// When a select changes, set A.side = B, and auto-recursively set B.OPP = A if empty or already pointing to A.
function onEdgeChange(side, toId){
  const A = cur(); // current map
  const oldExit = A.exits[side];
  A.exits[side] = (toId === "none") ? null : toId || null;

  // auto-reciprocal if target exists
  let autoLinked = false;
  if (A.exits[side] && model.maps.has(A.exits[side])){
    const B = model.maps.get(A.exits[side]);
    const opp = OPP[side];
    if (!B.exits[opp] || B.exits[opp] === A.id){
      if (!B.exits[opp]) {
        B.exits[opp] = A.id;
        autoLinked = true;
      }
    }
  }
  
  // Clean up old reciprocal link if we changed the exit
  if (oldExit && oldExit !== A.exits[side] && model.maps.has(oldExit)) {
    const oldB = model.maps.get(oldExit);
    const opp = OPP[side];
    if (oldB.exits[opp] === A.id) {
      oldB.exits[opp] = null;
    }
  }
  
  if (autoLinked) {
    const targetMap = model.maps.get(A.exits[side]);
    showNotification(`Auto-linked ${targetMap.name} ${OPP[side]} â†’ ${A.name}`);
  }
  
  syncHeader();
  syncToml();
  runLint();
}

// UI wiring
document.getElementById('newMap').onclick = makeNewMap;
document.getElementById('resize').onclick = ()=>{
  const m=cur(); m.W=+wIn.value; m.H=+hIn.value;
  m.grid = Array.from({length:m.H}, (_,y)=>Array.from({length:m.W},(_,x)=> (m.grid[y]?.[x] ?? CH.floor)));
  m.spawn.w = +swIn.value; m.spawn.h = +shIn.value;
  fit(); draw(); syncToml(); validateSpawn(); runLint();
};
mapsSel.onchange = e => setCurrent(e.target.value);
nameIn.onchange = e => { cur().name = e.target.value || cur().name; syncHeader(); syncToml(); runLint(); };

for (const side of ["left","right","top","bottom"]){
  edgeSel[side].onchange = e => onEdgeChange(side, e.target.value);
}

// Keyboard shortcuts: 1=wall, 2=erase, 3 or P=spawn
addEventListener('keydown', e=>{
  if (e.key === '1') setTool('wall');
  if (e.key === '2') setTool('erase');
  if (e.key === '3' || e.key.toLowerCase() === 'p') setTool('spawn');
});

document.getElementById('exportBtn').onclick = async ()=>{
  const map = cur();
  const filename = map.name.replace(/\s+/g,'_').toLowerCase() + ".toml";
  const content = toToml(map);
  
  if (directoryHandle) {
    try {
      await saveFileToDirectory(filename, content);
      showNotification(`Saved ${filename} to folder`);
    } catch (err) {
      console.error('Failed to save file:', err);
      showNotification('Save failed - falling back to download');
      fallbackDownload(content, filename);
    }
  } else {
    fallbackDownload(content, filename);
  }
};

document.getElementById('exportAllBtn').onclick = async ()=>{
  console.log('Download All clicked');
  console.log('directoryHandle exists:', !!directoryHandle);
  
  if (directoryHandle) {
    console.log('Directory handle name:', directoryHandle.name);
    try {
      const permission = await directoryHandle.queryPermission({ mode: 'readwrite' });
      console.log('Permission status:', permission);
    } catch (err) {
      console.log('Permission query failed:', err);
    }
    
    let saved = 0;
    let failed = 0;
    let directoryExpired = false;
    
    for (const [id, map] of model.maps.entries()) {
      const filename = map.name.replace(/\s+/g,'_').toLowerCase() + ".toml";
      const content = toToml(map);
      
      if (!directoryExpired) {
        try {
          console.log(`Attempting to save ${filename}...`);
          await saveFileToDirectory(filename, content);
          console.log(`âœ… Saved ${filename}`);
          saved++;
          continue;
        } catch (err) {
          console.log(`âŒ Failed to save ${filename}:`, err);
          if (err.message.includes('Directory handle expired')) {
            directoryExpired = true;
            showNotification('Directory access expired - remaining files will be downloaded. Use "Refresh Folder" to reconnect.');
          }
        }
      }
      
      // Fallback to download
      console.log(`ðŸ“ Downloading ${filename} as fallback`);
      failed++;
      fallbackDownload(content, filename);
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    if (failed === 0) {
      showNotification(`âœ… Downloaded ${saved} files to replace in maps folder`);
    } else if (saved > 0) {
      showNotification(`âš ï¸ Downloaded ${saved} files, ${failed} failed (check console)`);
    } else {
      showNotification(`ðŸ“ Downloaded ${failed} files (replace in maps folder)`);
    }
  } else {
    console.log('No directory handle - falling back to downloads');
    // Fallback to multiple downloads
    for (const [id, map] of model.maps.entries()) {
      const content = toToml(map);
      const filename = map.name.replace(/\s+/g,'_').toLowerCase() + ".toml";
      fallbackDownload(content, filename);
      // Small delay to prevent browser from blocking multiple downloads
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    showNotification(`ðŸ“ Downloaded ${model.maps.size} files (replace in maps folder)`);
  }
};

async function saveFileToDirectory(filename, content) {
  if (!directoryHandle) {
    throw new Error('No directory handle available');
  }

  try {
    console.log(`Attempting to save ${filename}...`);

    // Try to remove the existing file first (if it exists)
    try {
      await directoryHandle.removeEntry(filename);
      console.log(`Removed existing ${filename}`);
    } catch (removeErr) {
      if (removeErr.name !== 'NotFoundError') {
        console.log(`File ${filename} doesn't exist yet, will create new`);
      } else {
        console.log(`Could not remove ${filename}, will try to overwrite:`, removeErr);
      }
    }

    // Now create the new file
    const fileHandle = await directoryHandle.getFileHandle(filename, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    console.log(`âœ… Successfully saved ${filename}`);
    return; // Success!

  } catch (err) {
    console.error(`âŒ Failed to save ${filename}:`, err);

    if (err.name === 'InvalidStateError') {
      // Directory handle is stale - throw specific error to trigger fallback
      throw new Error(`Directory handle expired for ${filename}. Please use "Refresh Folder" or file will be downloaded.`);
    }

    if (err.name === 'NotAllowedError') {
      throw new Error(`Permission denied for ${filename}. File may be open in another program or folder access was revoked.`);
    }

    // Re-throw other errors
    throw err;
  }
}

function fallbackDownload(content, filename) {
  const blob = new Blob([content], {type:'text/plain'});
  const a = document.createElement('a'); 
  a.href = URL.createObjectURL(blob);
  a.download = filename; 
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 100);
}

function showNotification(message) {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 1000;
    background: #22c55e; color: white; padding: 12px 20px;
    border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-weight: 500; animation: fadeInOut 3s ease-in-out;
  `;
  notification.textContent = message;
  
  // Add CSS animation
  if (!document.getElementById('notification-styles')) {
    const style = document.createElement('style');
    style.id = 'notification-styles';
    style.textContent = `
      @keyframes fadeInOut {
        0% { opacity: 0; transform: translateX(100%); }
        15%, 85% { opacity: 1; transform: translateX(0); }
        100% { opacity: 0; transform: translateX(100%); }
      }
    `;
    document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 3000);
}

document.getElementById('importFiles').addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files);
  for (const f of files){
    const txt = await f.text();
    const obj = fromToml(txt);
    model.maps.set(obj.id, obj);
  }
  setCurrent(model.current ?? model.maps.keys().next().value);
});

// Optional: folder import and save (Chromium)
const openFolderBtn = document.getElementById('openFolder');
const fsHint = document.getElementById('fsHint');
const clearStorageBtn = document.getElementById('clearStorage');
let directoryHandle = null; // Store directory handle for saving

// Persistent directory handle storage
const DIRECTORY_HANDLE_KEY = 'lamy-maps-directory-handle';

if ('showDirectoryPicker' in window){
  const refreshFolderBtn = document.getElementById('refreshFolder');
  
  openFolderBtn.style.display = 'inline-block';
  fsHint.textContent = ' (Folder import/save available)';
  clearStorageBtn.style.display = 'inline-block';
  
  // Try to restore saved directory handle on page load
  restoreSavedDirectory();
  
  async function setupFolder() {
    try {
      directoryHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
      
      // Save the directory handle for next time
      await saveDirectoryHandle(directoryHandle);
      
      const previousId = model.current;
      clearModel();
      // Load all TOML files from the selected directory
  const loadedCount = await loadFromDirectory();
      
      const nextId = (previousId && model.maps.has(previousId))
        ? previousId
        : model.maps.keys().next().value;
  if (nextId) setCurrent(nextId);
  else model.current = null;
      updateExportButtons();
      
      // Show refresh button now that we have a folder
      refreshFolderBtn.style.display = 'inline-block';
      
      // Reset button styling
      openFolderBtn.textContent = 'Open Folderâ€¦';
      openFolderBtn.style.background = '';
      openFolderBtn.style.color = '';
      
      showNotification(`ðŸ”— Connected to folder, loaded ${loadedCount} maps`);
    } catch (err) {
      if (err.name !== 'AbortError') { // User didn't cancel
        console.error('Failed to open folder:', err);
        showNotification('Failed to open folder');
      }
    }
  }
  
  openFolderBtn.onclick = setupFolder;
  refreshFolderBtn.onclick = setupFolder;
  
  // Persistent permission button
  const persistentBtn = document.getElementById('requestPersistent');
  persistentBtn.onclick = async () => {
    try {
      const granted = await navigator.storage.persist();
      if (granted) {
        showNotification('âœ… Persistent storage granted! Folder access will be remembered longer.');
        persistentBtn.style.display = 'none';
      } else {
        showNotification(`ðŸ’¡ Persistent storage not granted (this is normal). Edge will still remember your folder for this session and often across restarts. To enable permanently: Edge Settings â†’ Cookies and site permissions â†’ All sites â†’ localhost â†’ Automatic downloads â†’ Allow`);
      }
    } catch (err) {
      console.error('Failed to request persistent storage:', err);
      showNotification('âŒ Could not request persistent storage');
    }
  };
  
  // Show persistent button if storage API is available
  if ('storage' in navigator && 'persist' in navigator.storage) {
    persistentBtn.style.display = 'inline-block';
  }
  
  clearStorageBtn.onclick = async () => {
    try {
      localStorage.removeItem(DIRECTORY_HANDLE_KEY + '_name');
      localStorage.removeItem(DIRECTORY_HANDLE_KEY + '_timestamp');
      console.log('Local cache cleared: directory handle metadata removed.');
    } catch (err) {
      console.error('Failed to clear local storage cache:', err);
      showNotification('âŒ Could not clear cache');
      return;
    }

    directoryHandle = null;
    refreshFolderBtn.style.display = 'none';
    openFolderBtn.textContent = 'Open Folderâ€¦';
    openFolderBtn.style.background = '';
    openFolderBtn.style.color = '';
    fsHint.textContent = ' (Folder import/save available)';

    clearModel();
    updateExportButtons();

    try {
      await loadInitialMaps();
      showNotification('ðŸ§¹ Cache cleared â€” manifest reloaded');
    } catch (err) {
      console.error('Failed to reload manifest after cache clear:', err);
      showNotification('ðŸ§¹ Cache cleared (reload failed; check console)');
    }
  };
  
  // Test save button
  const testBtn = document.getElementById('testSave');
  testBtn.onclick = async () => {
    console.log('=== DIRECTORY HANDLE DEBUG ===');
    console.log('directoryHandle exists:', !!directoryHandle);
    
    if (directoryHandle) {
      console.log('Directory name:', directoryHandle.name);
      try {
        const permission = await directoryHandle.queryPermission({ mode: 'readwrite' });
        console.log('Permission status:', permission);
        
        if (permission === 'granted') {
          console.log('Testing file creation...');
          const testFile = await directoryHandle.getFileHandle('test_save.txt', { create: true });
          const writable = await testFile.createWritable();
          await writable.write('Test save at ' + new Date().toISOString());
          await writable.close();
          console.log('âœ… Test file created successfully!');
          
          // Now test overwriting an existing file (remove and recreate)
          console.log('Testing file remove/recreate...');
          try {
            // First remove the file
            await directoryHandle.removeEntry('cave.toml');
            console.log('Removed cave.toml');
            
            // Then recreate it
            const recreatedFile = await directoryHandle.getFileHandle('cave.toml', { create: true });
            const recreatedWritable = await recreatedFile.createWritable();
            await recreatedWritable.write('[tiles]\nwall = "#"\nfloor = " "\n\n[spawn]\nx = 2\ny = 5\nw = 2\nh = 2\n\n# Test recreation\n');
            await recreatedWritable.close();
            console.log('âœ… File remove/recreate test successful!');
            showNotification('âœ… Both create and remove/recreate tests successful!');
          } catch (overwriteErr) {
            console.error('âŒ File remove/recreate test failed:', overwriteErr);
            showNotification('âŒ Create works, but remove/recreate failed: ' + overwriteErr.message);
          }
          
        } else {
          console.log('âŒ Permission not granted');
          showNotification('âŒ Permission not granted');
        }
      } catch (err) {
        console.error('âŒ Test save failed:', err);
        showNotification('âŒ Test save failed: ' + err.message);
      }
    } else {
      console.log('âŒ No directory handle');
      showNotification('âŒ No directory handle - use "Open Folder" first');
    }
  };
  
  // Show test button
  testBtn.style.display = 'inline-block';
}

async function saveDirectoryHandle(handle) {
  try {
    // Store the directory handle using IndexedDB via the browser's internal storage
    if ('indexedDB' in window && handle) {
      // Use the File System Access API's built-in persistence
      await navigator.storage.persist();
      
      // Store handle reference for restoration
      localStorage.setItem(DIRECTORY_HANDLE_KEY + '_name', handle.name);
      localStorage.setItem(DIRECTORY_HANDLE_KEY + '_timestamp', Date.now().toString());
      
      // The actual handle will be stored by the browser's permission system
      console.log('Directory handle saved for persistence');
    }
  } catch (err) {
    console.warn('Failed to save directory handle:', err);
  }
}

async function restoreSavedDirectory() {
  try {
    const savedName = localStorage.getItem(DIRECTORY_HANDLE_KEY + '_name');
    const savedTimestamp = localStorage.getItem(DIRECTORY_HANDLE_KEY + '_timestamp');
    
    if (!savedName) return;
    
    // Check if saved recently (within 7 days, Edge tends to remember longer)
    const age = Date.now() - parseInt(savedTimestamp || '0');
    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
    
    if (age > maxAge) {
      console.log('Saved directory handle expired (older than 7 days)');
      localStorage.removeItem(DIRECTORY_HANDLE_KEY + '_name');
      localStorage.removeItem(DIRECTORY_HANDLE_KEY + '_timestamp');
      return;
    }
    
    // Try to restore by requesting permission again (this is the limitation)
    // The browser should remember the permission for the same origin
    console.log(`Attempting to restore directory: ${savedName}`);
    
    // Show status that we remember the folder
    fsHint.textContent = ` (Last used: ${savedName} - click "Open Folder" to reconnect)`;
    openFolderBtn.textContent = `Reconnect to ${savedName}`;
    openFolderBtn.style.background = '#22c55e';
    openFolderBtn.style.color = 'white';
    
  } catch (err) {
    console.warn('Failed to restore directory handle:', err);
  }
}

async function loadFromDirectory() {
  if (!directoryHandle) return 0;
  
  let loadedCount = 0;
  try {
    for await (const [name, handle] of directoryHandle.entries()){
      if (name.toLowerCase().endsWith('.toml')){
        try {
          const file = await handle.getFile();
          const txt = await file.text();
          const obj = fromToml(txt);
          model.maps.set(obj.id, obj);
          loadedCount++;
        } catch (err) {
          console.warn(`Failed to load ${name}:`, err);
        }
      }
    }
    console.log('[Editor] Loaded maps from folder:', Array.from(model.maps.entries()).map(([id, m])=>`${m.name} (${id})`));
  } catch (err) {
    console.error('Error reading directory:', err);
  }
  
  return loadedCount;
}

function updateExportButtons() {
  const exportBtn = document.getElementById('exportBtn');
  const exportAllBtn = document.getElementById('exportAllBtn');
  
  if (directoryHandle) {
    exportBtn.textContent = 'Save TOML';
    exportAllBtn.textContent = 'Download All';
    fsHint.textContent = ' (Connected to folder - direct save enabled)';
  } else {
    exportBtn.textContent = 'Export TOML';
    exportAllBtn.textContent = 'Download All';
    fsHint.textContent = ' (Folder import/save available)';
  }
}

// Auto-discover ./maps/ on page load:
// 1) try maps/manifest.json (["maps/plains.toml", ...])
// 2) else parse the HTML listing at maps/ (works with `npx serve`)
async function loadInitialMaps(){
  clearModel();
  let found = 0;
  const urls = new Set();

  // (1) manifest
  try {
    const r = await fetch('maps/manifest.json');
    if (r.ok){
      const list = await r.json();
      for (const u of list) urls.add(u);
    }
  } catch {}

  // Load
  for (const url of urls){
    try{
      const txt = await (await fetch(url)).text();
      const obj = fromToml(txt);
      model.maps.set(obj.id, obj);
      found++;
    }catch{}
  }
  console.log('[Editor] Loaded maps from manifest:', Array.from(model.maps.entries()).map(([id, m])=>`${m.name} (${id})`));
  if (found > 0){
    const firstId = model.maps.keys().next().value;
    if (firstId) setCurrent(firstId);
  }
  if (!model.current) makeNewMap(); // fallback blank
}

window.addEventListener('DOMContentLoaded', ()=>{ loadInitialMaps(); });


// Painting
let down=false;
cv.addEventListener('pointerdown', e=>{ down=true; paint(e); });
cv.addEventListener('pointermove', e=>{ if (down) paint(e); });
addEventListener('pointerup', ()=> down=false);

function setTool(t){
  tool = t;
  for (const [k,id] of Object.entries(tools)){
    document.getElementById(id).classList.toggle('active', k===t);
  }
}
for (const [k,id] of Object.entries(tools)){ document.getElementById(id).onclick = ()=> setTool(k); }
setTool('wall');

function toCell(e){
  const rect = cv.getBoundingClientRect();
  const px = e.clientX - rect.left, py = e.clientY - rect.top;
  const tw = cv.width / cur().W, th = cv.height / cur().H;
  return { x: Math.floor(px / tw), y: Math.floor(py / th) };
}
function inBounds(x,y){ const m=cur(); return x>=0 && y>=0 && x<m.W && y<m.H; }

function paint(e){
  const m = cur(); const {x,y} = toCell(e); if (!inBounds(x,y)) return;
  if (tool==='wall'){ m.grid[y][x] = m.chars.wall; }
  else if (tool==='erase'){ m.grid[y][x] = m.chars.floor; }
  else if (tool==='spawn'){ m.spawn.x = x; m.spawn.y = y; }
  draw(); syncToml(); validateSpawn(); runLint();
}

// Spawn validation
function validateSpawn(){
  const m = cur();
  const ok = rectIsClear(m, m.spawn.x, m.spawn.y, m.spawn.w, m.spawn.h);
  warn.style.display = ok ? 'none' : 'block';
  warn.textContent = ok ? '' : 'Spawn overlaps walls: ensure a clear area of size Spawn WÃ—H.';
}

// Header / selects
function syncHeader(){
  const m = cur();
  nameIn.value = m.name;
  wIn.value = m.W; hIn.value = m.H; swIn.value = m.spawn.w; shIn.value = m.spawn.h;

  mapsSel.innerHTML = '';
  for (const [id, map] of model.maps.entries()){
    const o = document.createElement('option'); o.value=id; o.textContent=`${map.name} (${id.slice(0,8)})`;
    if (id===model.current) o.selected = true; mapsSel.appendChild(o);
  }
  const opts = [['none','â€” None â€”'], ...Array.from(model.maps.entries()).map(([id,m])=>[id, m.name])];
  for (const side of ["left","right","top","bottom"]){
    const sel = edgeSel[side];
    const prev = sel.value;
    sel.innerHTML = '';
    for (const [val,label] of opts){ const o=document.createElement('option'); o.value=val; o.textContent=label; sel.appendChild(o); }
    sel.value = cur().exits[side] ?? 'none';
  }
  validateSpawn();
}

// Keep TOML textarea current
function syncToml(){ tomlArea.value = toToml(cur()); }

// Render map
function fit(){
  const maxW = Math.min(innerWidth - 24, 1200);
  const aspect = cur().W / cur().H;
  let cw = maxW, ch = Math.round(cw / aspect);
  const maxH = innerHeight * 0.55;
  if (ch > maxH){ ch = Math.round(maxH); cw = Math.round(ch * aspect); }
  cv.width = cw; cv.height = ch;
}
addEventListener('resize', ()=>{ fit(); draw(); });

function draw(){
  const m = cur();
  const tw = cv.width / m.W, th = cv.height / m.H;

  ctx.fillStyle = getCSS('--floor','#fff'); ctx.fillRect(0,0,cv.width,cv.height);

  // grid
  ctx.strokeStyle = getCSS('--grid','#cfd8dc'); ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x=0;x<=m.W;x++){ const px = Math.round(x*tw)+.5; ctx.moveTo(px,0); ctx.lineTo(px,cv.height); }
  for (let y=0;y<=m.H;y++){ const py = Math.round(y*th)+.5; ctx.moveTo(0,py); ctx.lineTo(cv.width,py); }
  ctx.stroke();

  // tiles (draw all cells; spaces show as floor)
  for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
    if (m.grid[y][x]===m.chars.wall){
      ctx.fillStyle = getCSS('--wall','#000');
      ctx.fillRect(Math.round(x*tw), Math.round(y*th), Math.ceil(tw), Math.ceil(th));
    }
  }
  // spawn rectangle
  ctx.fillStyle = getCSS('--spawn','#1976d2');
  ctx.fillRect(Math.round(m.spawn.x*tw), Math.round(m.spawn.y*th), Math.ceil(m.spawn.w*tw), Math.ceil(m.spawn.h*th));
}

// TOML IO â€” preserve whitespace and blank rows
function toToml(m){
  const lines = m.grid.map(r => r.join("")); // keep trailing spaces by not trimming
  const extras = m.extras ?? makeEmptyExtras();
  const out = [];

  out.push(`id = "${escapeTomlString(m.id)}"`);
  out.push(`name = "${escapeTomlString(m.name)}"`);
  out.push("");

  out.push(`[tiles]`);
  out.push(`wall = "${escapeTomlString(m.chars.wall)}"`);
  out.push(`floor = "${escapeTomlString(m.chars.floor)}"`);
  out.push("");

  out.push(`[spawn]`);
  out.push(`x = ${m.spawn.x}`);
  out.push(`y = ${m.spawn.y}`);
  out.push(`w = ${m.spawn.w}`);
  out.push(`h = ${m.spawn.h}`);
  out.push("");

  if (extras.meta && Object.keys(extras.meta).length){
    out.push(`[meta]`);
    for (const [key, value] of Object.entries(extras.meta)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.legend && Object.keys(extras.legend).length){
    out.push(`[legend]`);
    for (const [key, value] of Object.entries(extras.legend)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.palette && Object.keys(extras.palette).length){
    out.push(`[palette]`);
    for (const [key, value] of Object.entries(extras.palette)){
      const serialized = formatTomlValue(value);
      if (serialized !== null) out.push(`${key} = ${serialized}`);
    }
    out.push("");
  }

  if (extras.poi && extras.poi.length){
    for (const entry of extras.poi){
      out.push(`[[poi]]`);
      writeOrderedTable(out, entry, ["id","name","x","y","kind","notes"]);
      out.push("");
    }
  }

  out.push(`grid = """`);
  out.push(...lines);
  out.push(`"""`);
  out.push("");

  if (extras.layers && Object.keys(extras.layers).length){
    for (const [layerName, layer] of Object.entries(extras.layers)){
      if (!layer || typeof layer !== 'object') continue;
      out.push(`[layers.${layerName}]`);
      for (const [key, value] of Object.entries(layer)){
        if (typeof value === 'string' && value.includes("\n")){
          out.push(`${key} = """`);
          out.push(...value.split("\n"));
          out.push(`"""`);
        } else {
          const serialized = formatTomlValue(value);
          if (serialized !== null) out.push(`${key} = ${serialized}`);
        }
      }
      out.push("");
    }
  }

  out.push(`[exits]`);
  if (m.exits.left) out.push(`left = "${escapeTomlString(m.exits.left)}"`);
  if (m.exits.right) out.push(`right = "${escapeTomlString(m.exits.right)}"`);
  if (m.exits.top) out.push(`top = "${escapeTomlString(m.exits.top)}"`);
  if (m.exits.bottom) out.push(`bottom = "${escapeTomlString(m.exits.bottom)}"`);
  out.push("");

  if (extras.triggers && extras.triggers.length){
    for (const entry of extras.triggers){
      out.push(`[[triggers]]`);
      writeOrderedTable(out, entry, ["id","type","event","x","y","w","h","text"]);
      out.push("");
    }
  }

  while (out.length && out[out.length-1] === "") out.pop();
  return out.join("\n") + "\n";
}

function escapeTomlString(str){
  return String(str ?? "").replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function formatTomlValue(value){
  if (value === null || value === undefined) return null;
  if (typeof value === 'number') return Number.isFinite(value) ? String(value) : null;
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  return `"${escapeTomlString(value)}"`;
}

function writeOrderedTable(out, entry, order){
  const seen = new Set();
  for (const key of order){
    if (entry[key] === undefined) continue;
    const serialized = formatTomlValue(entry[key]);
    if (serialized !== null){
      out.push(`${key} = ${serialized}`);
      seen.add(key);
    }
  }
  for (const key of Object.keys(entry)){
    if (seen.has(key)) continue;
    const serialized = formatTomlValue(entry[key]);
    if (serialized !== null) out.push(`${key} = ${serialized}`);
  }
}
function fromToml(txt){
  const t = parseTOML(txt);
  const rows = String(t.grid).replace(/\r\n?/g,"\n").split("\n"); // no trimming
  const H = rows.length, W = Math.max(...rows.map(r=>r.length));
  const grid = Array.from({length:H}, (_,y)=>{
    const line = rows[y] ?? "";
    const padded = line.padEnd(W, (t.tiles?.floor ?? ' '));
    return Array.from({length:W}, (_,x)=> padded[x] ?? (t.tiles?.floor ?? ' '));
  });
  const extras = cloneExtrasFromToml(t);
  return {
    id: t.id, name: t.name || t.id.slice(0,8),
    W, H, grid,
    spawn: { x: t.spawn.x, y: t.spawn.y, w: t.spawn.w, h: t.spawn.h },
    exits: { left: t.exits?.left ?? null, right: t.exits?.right ?? null, top: t.exits?.top ?? null, bottom: t.exits?.bottom ?? null },
    chars: { wall: t.tiles?.wall ?? '#', floor: t.tiles?.floor ?? ' ' },
    extras
  };
}

function parseTOML(src){
  const out = {};
  let ctx = out;
  let path = [];
  let inML = false, mlKey = "", mlBuf = [], mlTarget = out;

  const isRootKey = k => (k === "id" || k === "name" || k === "grid");
  const set = (obj, key, val) => { obj[key] = val; };

  const shouldForceRoot = (key, path) => {
    if (!isRootKey(key)) return false;
    if (key === "grid"){
      if (path.length === 0) return true;
      if (path.length === 1 && path[0] !== "layers") return true;
      return false;
    }
    return path.length === 0;
  };

  const ensureTable = (segments) => {
    let target = out;
    for (const seg of segments){
      target[seg] ||= {};
      if (typeof target[seg] !== "object" || Array.isArray(target[seg])){
        throw new Error(`TOML: attempted to reuse key '${segments.join('.')}' as non-table.`);
      }
      target = target[seg];
    }
    return target;
  };

  const ensureArrayTable = (segments) => {
    const head = segments.slice(0, -1);
    const leaf = segments[segments.length - 1];
    let target = out;
    for (const seg of head){
      target[seg] ||= {};
      if (typeof target[seg] !== "object" || Array.isArray(target[seg])){
        throw new Error(`TOML: attempted to reuse key '${segments.join('.')}' as non-table.`);
      }
      target = target[seg];
    }
    target[leaf] ||= [];
    if (!Array.isArray(target[leaf])){
      throw new Error(`TOML: key '${segments.join('.')}' already used as non-array.`);
    }
    const obj = {};
    target[leaf].push(obj);
    return obj;
  };

  const lines = src.replace(/\r\n?/g,"\n").split("\n");
  for (let raw of lines){
    const line = raw.trim();

    if (!inML){
      if (!line || line.startsWith("#")) continue;

      let m;
      if ((m = line.match(/^\[\[([A-Za-z0-9_.]+)\]\]$/))){
        const segments = m[1].split('.');
        ctx = ensureArrayTable(segments);
        path = [segments[0]];
        continue;
      }

      if ((m = line.match(/^\[([A-Za-z0-9_.]+)\]$/))){
        const segments = m[1].split('.');
        ctx = ensureTable(segments);
        path = segments;
        continue;
      }

      if ((m = line.match(/^([A-Za-z0-9_]+)\s*=\s*"""$/))){
        const key = m[1];
        inML = true;
        mlKey = key;
        mlBuf = [];
        const forceRoot = shouldForceRoot(key, path);
        mlTarget = forceRoot ? out : ctx;
        if (forceRoot){ ctx = out; path = []; }
        continue;
      }

      if ((m = line.match(/^([A-Za-z0-9_]+)\s*=\s*(.+)$/))){
        const key = m[1];
        let rhs = m[2].trim();
        let val;
        if ((/^".*"$/.test(rhs)) || (/^'.*'$/.test(rhs))){
          val = rhs.slice(1, -1)
            .replace(/\\\\/g, "\\")
            .replace(/\\"/g, '"')
            .replace(/\\n/g, "\n")
            .replace(/\\r/g, "\r")
            .replace(/\\t/g, "\t");
        } else if (/^(true|false)$/i.test(rhs)){
          val = /^true$/i.test(rhs);
        } else if (/^-?\d+$/.test(rhs)){
          val = parseInt(rhs, 10);
        } else if (/^-?\d*\.\d+$/.test(rhs)){
          val = parseFloat(rhs);
        } else {
          throw new Error("Unsupported TOML value: " + rhs);
        }
        const forceRoot = shouldForceRoot(key, path);
        const target = forceRoot ? out : ctx;
        set(target, key, val);
        if (forceRoot){ ctx = out; path = []; }
        continue;
      }

      // Unknown line -> ignore
    } else {
      if (line === `"""`){
        set(mlTarget, mlKey, mlBuf.join("\n"));
        inML = false; mlKey = ""; mlBuf = []; mlTarget = out;
      } else {
        mlBuf.push(raw);
      }
    }
  }
  if (inML) throw new Error("Unterminated multiline string");
  return out;
}



// Lint: dangling and conflicts
function runLint(){
  const problems = [];
  // clear styles
  for (const s of Object.values(edgeSel)) s.classList.remove('bad');

  for (const [id,m] of model.maps.entries()){
    for (const [side,to] of Object.entries(m.exits)){
      if (!to) continue;
      if (!model.maps.has(to)){
        if (id === model.current) edgeSel[side].classList.add('bad');
        problems.push(`Dangling: ${m.name} ${side} â†’ ${to} (missing map)`);
        continue;
      }
      const opp = OPP[side];
      const n = model.maps.get(to);
      if (!n.exits[opp]){
        // auto-reciprocal if empty
        n.exits[opp] = id;
      } else if (n.exits[opp] !== id){
        if (id === model.current) edgeSel[side].classList.add('bad');
        problems.push(`Conflict: ${m.name} ${side} â†’ ${n.name}, but ${n.name} ${opp} â†’ ${short(n.exits[opp])}`);
      }
    }
  }

  if (problems.length){
    warn.classList.remove('ok');
    warn.style.display = 'block';
    warn.textContent = problems.join("\n");
  } else {
    warn.classList.add('ok');
    warn.style.display = 'block';
    warn.textContent = 'âœ“ No link issues';
  }
}

function short(id){
  const m = model.maps.get(id);
  return m ? `${m.name}` : id.slice(0,8);
}

// World overview
// World overview â€” clickable atlas
const worldCv = document.getElementById('world'), wctx = worldCv.getContext('2d');
let Z=1, pan={x:20,y:20}, dragging=false, last={x:0,y:0};
let worldRects = []; // [{id,x,y,w,h}] in world coords (pre-translate/scale)
let hoverId = null;

document.getElementById('renderWorld').onclick = drawWorld;
document.getElementById('z').oninput = e => { Z=+e.target.value; drawWorld(); };

worldCv.addEventListener('pointerdown', e=>{
  const pt = worldPoint(e);
  // If we clicked a map rect: select it; else begin pan
  const hit = hitTest(pt.x, pt.y);
  if (hit){ setCurrent(hit.id); drawWorld(); return; }
  dragging=true; last={x:e.clientX,y:e.clientY};
});
addEventListener('pointerup', ()=> dragging=false);
addEventListener('pointermove', e=>{
  if (dragging){
    pan.x+=e.clientX-last.x; pan.y+=e.clientY-last.y; last={x:e.clientX,y:e.clientY};
    drawWorld(); return;
  }
  // hover
  const pt = worldPoint(e);
  const hit = hitTest(pt.x, pt.y);
  const nextHover = hit ? hit.id : null;
  if (nextHover !== hoverId){
    hoverId = nextHover;
    worldCv.style.cursor = hoverId ? 'pointer' : 'grab';
    drawWorld();
  }
});

function layout(){
  const pos = new Map(), q = [];
  const DIR = { left:{x:-1,y:0}, right:{x:1,y:0}, top:{x:0,y:-1}, bottom:{x:0,y:1} };
  const start = model.current ?? Array.from(model.maps.keys())[0];
  if (!start) return pos;
  pos.set(start, {x:0,y:0}); q.push(start);
  while(q.length){
    const id = q.shift(), p = pos.get(id), m = model.maps.get(id);
    for (const [side,to] of Object.entries(m.exits)){
      if (!to || !model.maps.has(to)) continue;
      if (!pos.has(to)){
        const d = DIR[side];
        pos.set(to, { x: p.x + d.x, y: p.y + d.y });
        q.push(to);
      }
    }
  }
  return pos;
}

function drawWorld(){
  resizeWorld();
  wctx.clearRect(0,0,worldCv.width,worldCv.height);
  const pos = layout(); wctx.save(); wctx.translate(pan.x, pan.y); wctx.scale(Z,Z);
  const tile = 6;

  worldRects = [];

  // links first
  wctx.strokeStyle="#4b5563"; wctx.lineWidth = 1/Z;
  for (const [id,p] of pos){
    const m = model.maps.get(id); if (!m) continue;
    const A = {x: p.x*(m.W+4)*tile, y: p.y*(m.H+4)*tile, w: m.W*tile, h: m.H*tile};
    for (const [side,to] of Object.entries(m.exits)){
      if (!to || !pos.has(to)) continue;
      const n = model.maps.get(to), q = pos.get(to);
      const B = {x: q.x*(n.W+4)*tile, y: q.y*(n.H+4)*tile, w: n.W*tile, h: n.H*tile};
      wctx.beginPath(); wctx.moveTo(A.x+A.w/2, A.y+A.h/2); wctx.lineTo(B.x+B.w/2, B.y+B.h/2); wctx.stroke();
    }
  }

  // maps
  for (const [id,p] of pos){
    const m = model.maps.get(id); if (!m) continue;
    const ox = p.x*(m.W+4)*tile, oy = p.y*(m.H+4)*tile;
    const rect = { id, x: ox, y: oy, w: m.W*tile, h: m.H*tile };
    worldRects.push(rect);

    // card bg + title
    wctx.fillStyle="#111827"; wctx.fillRect(ox-4, oy-24, m.W*tile+8, m.H*tile+28);
    wctx.fillStyle="#e5e7eb"; wctx.fillText(`${m.name}`, ox, oy-8);

    // map cells
    for (let y=0;y<m.H;y++) for (let x=0;x<m.W;x++){
      wctx.fillStyle = (m.grid[y][x]===m.chars.wall) ? "#000" : "#fff";
      wctx.fillRect(ox+x*tile, oy+y*tile, tile, tile);
    }

    // spawn
    wctx.fillStyle="#1976d2";
    wctx.fillRect(ox+m.spawn.x*tile, oy+m.spawn.y*tile, m.spawn.w*tile, m.spawn.h*tile);

    // highlight hover/current
    if (id === hoverId || id === model.current){
      wctx.lineWidth = 2/Z;
      wctx.strokeStyle = (id === model.current) ? "#22c55e" : "#eab308";
      wctx.strokeRect(rect.x-2, rect.y-2, rect.w+4, rect.h+4);
    }
  }

  wctx.restore();
}

function resizeWorld(){ worldCv.width = innerWidth - 24; worldCv.height = Math.round(innerHeight * 0.44); }

function worldPoint(e){
  const r = worldCv.getBoundingClientRect();
  const x = (e.clientX - r.left - pan.x) / Z;
  const y = (e.clientY - r.top  - pan.y) / Z;
  return { x, y };
}
function hitTest(x,y){
  for (let i=worldRects.length-1;i>=0;i--){
    const r = worldRects[i];
    if (x>=r.x && y>=r.y && x<=r.x+r.w && y<=r.y+r.h) return r;
  }
  return null;
}




function rectIsClear(m, x, y, w, h){
  for (let ty=y; ty<y+h; ty++) for (let tx=x; tx<x+w; tx++){
    if (m.grid[ty]?.[tx] === m.chars.wall) return false;
  }
  return true;
}
function getCSS(name, fallback){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback; }
</script>
