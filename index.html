<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Top-Down RPG — Lesson 1</title>
  <style>
    :root { --tile: 32px; --bg: #ffffff; --wall: #000000; --player: #1976d2; }
    html, body { height: 100%; margin: 0; background: var(--bg); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { display: grid; place-items: start center; padding: 12px; gap: 8px; }
    canvas { image-rendering: pixelated; box-shadow: 0 6px 24px rgba(0,0,0,.1); }
    .hud { color:#333; }
    code { background:#f4f4f4; padding:2px 4px; border-radius:4px; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
  <div class="hud">
    <strong>Controls:</strong> Arrow keys / WASD.  
    <strong>Legend:</strong> <code>#</code> wall, space floor, <code>P</code> player spawn.
  </div>
</div>

<script>
/* ---------------------
   TEXT LEVEL (data-driven)
---------------------- */
const LEVEL = `
########################
#   #######            #
#   # P   #            #
#   #     #            #
#   #  ####            #
#                      #
#                      #
#                      #
#                      #
#                      #
########################
`.trim();

/* ---------------------
   BASIC ENGINE SCAFFOLD
---------------------- */
const TILE = 32;
const solid = new Set(["#"]); // what blocks movement
const map = parseLevel(LEVEL);
const canvas = document.getElementById("game");
canvas.width  = map.w * TILE;
canvas.height = map.h * TILE;
const ctx = canvas.getContext("2d");

const input = mkInput();
const player = { x: map.spawn.x + 0.1, y: map.spawn.y + 0.1, w: 0.8, h: 0.8, speed: 6.0 }; // in tiles

// fixed-step loop (stable simulation regardless of frame rate)
let last = 0, acc = 0;
const STEP = 1/60, MAX_FRAME = 0.25;
requestAnimationFrame(loop);

function loop(tms){
  const dt = Math.min((tms - last) / 1000, MAX_FRAME); last = tms; acc += dt;
  while (acc >= STEP) { update(STEP); acc -= STEP; }
  render();
  requestAnimationFrame(loop);
}

/* ---------------------
   UPDATE
---------------------- */
function update(dt){
  // directional intent
  let dx = 0, dy = 0;
  if (input.left)  dx -= 1;
  if (input.right) dx += 1;
  if (input.up)    dy -= 1;
  if (input.down)  dy += 1;

  // normalize diagonal
  if (dx && dy){ const s = Math.SQRT1_2; dx *= s; dy *= s; }

  const vx = dx * player.speed * dt;   // tiles per second → tiles per step
  const vy = dy * player.speed * dt;

  // move with axis separation (simple, slidey)
  tryMove(player, vx, 0);
  tryMove(player, 0, vy);
}

function tryMove(ent, mx, my){
  const nx = ent.x + mx, ny = ent.y + my;
  // AABB → sample four corners against solid tiles
  const left   = nx,              right  = nx + ent.w;
  const top    = ny,              bottom = ny + ent.h;

  // check X axis
  if (mx !== 0){
    const testX = mx > 0 ? right : left;
    if (hitsSolid(testX, top) || hitsSolid(testX, bottom - 0.001)){
      // push back to tile boundary
      const tileX = (mx > 0 ? Math.floor(right) : Math.ceil(left)) + (mx > 0 ? -ent.w : 0);
      ent.x = tileX;
    } else {
      ent.x = nx;
    }
  }

  // recompute bounds after X adjustment
  const lx = ent.x, rx = ent.x + ent.w;

  // check Y axis
  if (my !== 0){
    const testY = my > 0 ? bottom : top;
    if (hitsSolid(lx, testY) || hitsSolid(rx - 0.001, testY)){
      const tileY = (my > 0 ? Math.floor(bottom) : Math.ceil(top)) + (my > 0 ? -ent.h : 0);
      ent.y = tileY;
    } else {
      ent.y = ny;
    }
  }
}

function hitsSolid(px, py){
  const tx = Math.floor(px), ty = Math.floor(py);
  return outOfBounds(tx, ty) || solid.has(tileAt(tx, ty));
}

/* ---------------------
   RENDER
---------------------- */
function render(){
  // clear
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // draw tiles
  for (let y = 0; y < map.h; y++){
    for (let x = 0; x < map.w; x++){
      if (map.grid[y][x] === "#"){
        ctx.fillStyle = "#000000";
        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
      }
    }
  }
  // draw player
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--player").trim() || "#1976d2";
  ctx.fillRect(player.x * TILE, player.y * TILE, player.w * TILE, player.h * TILE);
}

/* ---------------------
   HELPERS
---------------------- */
function parseLevel(text){
  const rows = text.split("\n");
  const h = rows.length, w = Math.max(...rows.map(r => r.length));
  const grid = [];
  let spawn = {x:1, y:1};
  for (let y=0; y<h; y++){
    grid[y] = [];
    for (let x=0; x<w; x++){
      const ch = rows[y][x] ?? " ";
      grid[y][x] = ch === "P" ? " " : ch;
      if (ch === "P") spawn = { x, y };
    }
  }
  return { w, h, grid, spawn };
}
function tileAt(x, y){ return map.grid[y]?.[x] ?? "#"; }
function outOfBounds(x, y){ return x < 0 || y < 0 || x >= map.w || y >= map.h; }

function mkInput(){
  const st = {left:false,right:false,up:false,down:false};
  const on = (e, v=true) => {
    const k = e.key.toLowerCase();
    if (["arrowleft","a"].includes(k)) st.left = v;
    if (["arrowright","d"].includes(k)) st.right = v;
    if (["arrowup","w"].includes(k)) st.up = v;
    if (["arrowdown","s"].includes(k)) st.down = v;
  };
  addEventListener("keydown", e => { on(e, true); if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"," "].includes(e.key)) e.preventDefault(); });
  addEventListener("keyup",   e => on(e, false));
  return st;
}
</script>
</body>
</html>
